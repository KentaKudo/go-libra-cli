// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proof.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type AccumulatorProof struct {
	// The bitmap indicating which siblings are default. 1 means non-default and
	// 0 means default. The LSB corresponds to the sibling at the bottom of the
	// accumulator. The leftmost 1-bit corresponds to the sibling at the level
	// just below root level in the accumulator, since this one is always
	// non-default.
	Bitmap uint64 `protobuf:"varint,1,opt,name=bitmap,proto3" json:"bitmap,omitempty"`
	// The non-default siblings. The ones near the root are at the beginning of
	// the list.
	NonDefaultSiblings [][]byte `protobuf:"bytes,2,rep,name=non_default_siblings,json=nonDefaultSiblings,proto3" json:"non_default_siblings,omitempty"`
}

func (m *AccumulatorProof) Reset()      { *m = AccumulatorProof{} }
func (*AccumulatorProof) ProtoMessage() {}
func (*AccumulatorProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_473d204b28f447f0, []int{0}
}
func (m *AccumulatorProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccumulatorProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccumulatorProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccumulatorProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccumulatorProof.Merge(m, src)
}
func (m *AccumulatorProof) XXX_Size() int {
	return m.Size()
}
func (m *AccumulatorProof) XXX_DiscardUnknown() {
	xxx_messageInfo_AccumulatorProof.DiscardUnknown(m)
}

var xxx_messageInfo_AccumulatorProof proto.InternalMessageInfo

func (m *AccumulatorProof) GetBitmap() uint64 {
	if m != nil {
		return m.Bitmap
	}
	return 0
}

func (m *AccumulatorProof) GetNonDefaultSiblings() [][]byte {
	if m != nil {
		return m.NonDefaultSiblings
	}
	return nil
}

type SparseMerkleProof struct {
	// This proof can be used to authenticate whether a given leaf exists in the
	// tree or not. In Rust:
	//   - If this is `Some(HashValue, HashValue)`
	//     - If the first `HashValue` equals requested key, this is an inclusion
	//       proof and the second `HashValue` equals the hash of the
	//       corresponding account blob.
	//     - Otherwise this is a non-inclusion proof. The first `HashValue` is
	//       the only key that exists in the subtree and the second `HashValue`
	//       equals the hash of the corresponding account blob.
	//   - If this is `None`, this is also a non-inclusion proof which indicates
	//     the subtree is empty.
	//
	// In protobuf, this leaf field should either be
	//   - empty, which corresponds to None in the Rust structure.
	//   - exactly 64 bytes, which corresponds to Some<(HashValue, HashValue)>
	//     in the Rust structure.
	Leaf []byte `protobuf:"bytes,1,opt,name=leaf,proto3" json:"leaf,omitempty"`
	// The bitmap indicating which siblings are default. 1 means non-default and
	// 0 means default. The MSB of the first byte corresponds to the sibling at
	// the top of the Sparse Merkle Tree. The rightmost 1-bit of the last byte
	// corresponds to the sibling at the bottom, since this one is always
	// non-default.
	Bitmap []byte `protobuf:"bytes,2,opt,name=bitmap,proto3" json:"bitmap,omitempty"`
	// The non-default siblings. The ones near the root are at the beginning of
	// the list.
	NonDefaultSiblings [][]byte `protobuf:"bytes,3,rep,name=non_default_siblings,json=nonDefaultSiblings,proto3" json:"non_default_siblings,omitempty"`
}

func (m *SparseMerkleProof) Reset()      { *m = SparseMerkleProof{} }
func (*SparseMerkleProof) ProtoMessage() {}
func (*SparseMerkleProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_473d204b28f447f0, []int{1}
}
func (m *SparseMerkleProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SparseMerkleProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SparseMerkleProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SparseMerkleProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SparseMerkleProof.Merge(m, src)
}
func (m *SparseMerkleProof) XXX_Size() int {
	return m.Size()
}
func (m *SparseMerkleProof) XXX_DiscardUnknown() {
	xxx_messageInfo_SparseMerkleProof.DiscardUnknown(m)
}

var xxx_messageInfo_SparseMerkleProof proto.InternalMessageInfo

func (m *SparseMerkleProof) GetLeaf() []byte {
	if m != nil {
		return m.Leaf
	}
	return nil
}

func (m *SparseMerkleProof) GetBitmap() []byte {
	if m != nil {
		return m.Bitmap
	}
	return nil
}

func (m *SparseMerkleProof) GetNonDefaultSiblings() [][]byte {
	if m != nil {
		return m.NonDefaultSiblings
	}
	return nil
}

// The complete proof used to authenticate a signed transaction.
type SignedTransactionProof struct {
	LedgerInfoToTransactionInfoProof *AccumulatorProof `protobuf:"bytes,1,opt,name=ledger_info_to_transaction_info_proof,json=ledgerInfoToTransactionInfoProof,proto3" json:"ledger_info_to_transaction_info_proof,omitempty"`
	TransactionInfo                  *TransactionInfo  `protobuf:"bytes,2,opt,name=transaction_info,json=transactionInfo,proto3" json:"transaction_info,omitempty"`
}

func (m *SignedTransactionProof) Reset()      { *m = SignedTransactionProof{} }
func (*SignedTransactionProof) ProtoMessage() {}
func (*SignedTransactionProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_473d204b28f447f0, []int{2}
}
func (m *SignedTransactionProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedTransactionProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignedTransactionProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignedTransactionProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedTransactionProof.Merge(m, src)
}
func (m *SignedTransactionProof) XXX_Size() int {
	return m.Size()
}
func (m *SignedTransactionProof) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedTransactionProof.DiscardUnknown(m)
}

var xxx_messageInfo_SignedTransactionProof proto.InternalMessageInfo

func (m *SignedTransactionProof) GetLedgerInfoToTransactionInfoProof() *AccumulatorProof {
	if m != nil {
		return m.LedgerInfoToTransactionInfoProof
	}
	return nil
}

func (m *SignedTransactionProof) GetTransactionInfo() *TransactionInfo {
	if m != nil {
		return m.TransactionInfo
	}
	return nil
}

// The complete proof used to authenticate an account state.
type AccountStateProof struct {
	LedgerInfoToTransactionInfoProof *AccumulatorProof  `protobuf:"bytes,1,opt,name=ledger_info_to_transaction_info_proof,json=ledgerInfoToTransactionInfoProof,proto3" json:"ledger_info_to_transaction_info_proof,omitempty"`
	TransactionInfo                  *TransactionInfo   `protobuf:"bytes,2,opt,name=transaction_info,json=transactionInfo,proto3" json:"transaction_info,omitempty"`
	TransactionInfoToAccountProof    *SparseMerkleProof `protobuf:"bytes,3,opt,name=transaction_info_to_account_proof,json=transactionInfoToAccountProof,proto3" json:"transaction_info_to_account_proof,omitempty"`
}

func (m *AccountStateProof) Reset()      { *m = AccountStateProof{} }
func (*AccountStateProof) ProtoMessage() {}
func (*AccountStateProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_473d204b28f447f0, []int{3}
}
func (m *AccountStateProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountStateProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountStateProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountStateProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountStateProof.Merge(m, src)
}
func (m *AccountStateProof) XXX_Size() int {
	return m.Size()
}
func (m *AccountStateProof) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountStateProof.DiscardUnknown(m)
}

var xxx_messageInfo_AccountStateProof proto.InternalMessageInfo

func (m *AccountStateProof) GetLedgerInfoToTransactionInfoProof() *AccumulatorProof {
	if m != nil {
		return m.LedgerInfoToTransactionInfoProof
	}
	return nil
}

func (m *AccountStateProof) GetTransactionInfo() *TransactionInfo {
	if m != nil {
		return m.TransactionInfo
	}
	return nil
}

func (m *AccountStateProof) GetTransactionInfoToAccountProof() *SparseMerkleProof {
	if m != nil {
		return m.TransactionInfoToAccountProof
	}
	return nil
}

// The complete proof used to authenticate an event.
type EventProof struct {
	LedgerInfoToTransactionInfoProof *AccumulatorProof `protobuf:"bytes,1,opt,name=ledger_info_to_transaction_info_proof,json=ledgerInfoToTransactionInfoProof,proto3" json:"ledger_info_to_transaction_info_proof,omitempty"`
	TransactionInfo                  *TransactionInfo  `protobuf:"bytes,2,opt,name=transaction_info,json=transactionInfo,proto3" json:"transaction_info,omitempty"`
	TransactionInfoToEventProof      *AccumulatorProof `protobuf:"bytes,3,opt,name=transaction_info_to_event_proof,json=transactionInfoToEventProof,proto3" json:"transaction_info_to_event_proof,omitempty"`
}

func (m *EventProof) Reset()      { *m = EventProof{} }
func (*EventProof) ProtoMessage() {}
func (*EventProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_473d204b28f447f0, []int{4}
}
func (m *EventProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventProof.Merge(m, src)
}
func (m *EventProof) XXX_Size() int {
	return m.Size()
}
func (m *EventProof) XXX_DiscardUnknown() {
	xxx_messageInfo_EventProof.DiscardUnknown(m)
}

var xxx_messageInfo_EventProof proto.InternalMessageInfo

func (m *EventProof) GetLedgerInfoToTransactionInfoProof() *AccumulatorProof {
	if m != nil {
		return m.LedgerInfoToTransactionInfoProof
	}
	return nil
}

func (m *EventProof) GetTransactionInfo() *TransactionInfo {
	if m != nil {
		return m.TransactionInfo
	}
	return nil
}

func (m *EventProof) GetTransactionInfoToEventProof() *AccumulatorProof {
	if m != nil {
		return m.TransactionInfoToEventProof
	}
	return nil
}

func init() {
	proto.RegisterType((*AccumulatorProof)(nil), "types.AccumulatorProof")
	proto.RegisterType((*SparseMerkleProof)(nil), "types.SparseMerkleProof")
	proto.RegisterType((*SignedTransactionProof)(nil), "types.SignedTransactionProof")
	proto.RegisterType((*AccountStateProof)(nil), "types.AccountStateProof")
	proto.RegisterType((*EventProof)(nil), "types.EventProof")
}

func init() { proto.RegisterFile("proof.proto", fileDescriptor_473d204b28f447f0) }

var fileDescriptor_473d204b28f447f0 = []byte{
	// 409 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x94, 0xcf, 0x4a, 0xe3, 0x40,
	0x1c, 0xc7, 0x33, 0x69, 0xb7, 0x87, 0x69, 0x61, 0xdb, 0xb0, 0x64, 0xcb, 0x2e, 0x3b, 0x5b, 0x03,
	0x42, 0x4f, 0x45, 0xaa, 0x2f, 0x50, 0xd1, 0x83, 0x07, 0x41, 0x92, 0x1e, 0x95, 0x30, 0x49, 0x27,
	0x35, 0x98, 0xce, 0x2f, 0x26, 0x13, 0xc1, 0x9b, 0x8f, 0xe0, 0xd1, 0x07, 0xf0, 0xe0, 0x8b, 0x08,
	0x1e, 0x7b, 0xec, 0xd1, 0xa6, 0x17, 0x8f, 0x7d, 0x04, 0xe9, 0x24, 0xd0, 0x36, 0xb5, 0x78, 0xee,
	0x2d, 0xf3, 0xfb, 0x31, 0xdf, 0x3f, 0x1f, 0xc2, 0xe0, 0x6a, 0x18, 0x01, 0x78, 0x9d, 0x30, 0x02,
	0x01, 0xda, 0x0f, 0x71, 0x1f, 0xb2, 0xf8, 0x8f, 0x2e, 0x22, 0xca, 0x63, 0xea, 0x0a, 0x1f, 0xb8,
	0xed, 0x73, 0x0f, 0xb2, 0xb5, 0x71, 0x89, 0xeb, 0x3d, 0xd7, 0x4d, 0x46, 0x49, 0x40, 0x05, 0x44,
	0x17, 0x8b, 0x8b, 0x9a, 0x8e, 0x2b, 0x8e, 0x2f, 0x46, 0x34, 0x6c, 0xa2, 0x16, 0x6a, 0x97, 0xcd,
	0xfc, 0xa4, 0x1d, 0xe0, 0x5f, 0x1c, 0xb8, 0x3d, 0x60, 0x1e, 0x4d, 0x02, 0x61, 0xc7, 0xbe, 0x13,
	0xf8, 0x7c, 0x18, 0x37, 0xd5, 0x56, 0xa9, 0x5d, 0x33, 0x35, 0x0e, 0xfc, 0x24, 0x5b, 0x59, 0xf9,
	0xc6, 0xb8, 0xc5, 0x0d, 0x2b, 0xa4, 0x51, 0xcc, 0xce, 0x59, 0x74, 0x13, 0xb0, 0x4c, 0x5e, 0xc3,
	0xe5, 0x80, 0x51, 0x4f, 0x8a, 0xd7, 0x4c, 0xf9, 0xbd, 0x62, 0xa9, 0xca, 0xe9, 0x77, 0x96, 0xa5,
	0xad, 0x96, 0xaf, 0x08, 0xeb, 0x96, 0x3f, 0xe4, 0x6c, 0xd0, 0x5f, 0x36, 0xce, 0x8c, 0xaf, 0xf1,
	0x7e, 0xc0, 0x06, 0x43, 0x16, 0x49, 0x00, 0xb6, 0x00, 0xbb, 0x08, 0xc5, 0x96, 0xe4, 0x64, 0xb2,
	0x6a, 0xf7, 0x77, 0x47, 0xa2, 0xeb, 0x14, 0xf9, 0x98, 0xad, 0x4c, 0xe5, 0x8c, 0x7b, 0xd0, 0x87,
	0x15, 0x97, 0xc5, 0x20, 0x73, 0xea, 0xe1, 0x7a, 0x51, 0x5a, 0x16, 0xab, 0x76, 0xf5, 0x5c, 0xb4,
	0x70, 0xcd, 0xfc, 0x29, 0xd6, 0x07, 0xc6, 0xb3, 0x8a, 0x1b, 0x3d, 0xd7, 0x85, 0x84, 0x0b, 0x4b,
	0x50, 0xc1, 0x76, 0xaf, 0x82, 0xe6, 0xe0, 0xbd, 0x8d, 0x74, 0x02, 0x6c, 0x9a, 0xb5, 0xca, 0x83,
	0x96, 0xa4, 0x66, 0x33, 0xd7, 0xdc, 0xf8, 0x5b, 0xcc, 0x7f, 0x05, 0xd5, 0x3e, 0xe4, 0x54, 0xe4,
	0xda, 0x78, 0x52, 0x31, 0x3e, 0xbd, 0x63, 0xf9, 0x71, 0xb7, 0xf8, 0x5c, 0xe1, 0xff, 0x5f, 0xf1,
	0x61, 0x8b, 0x3a, 0x6b, 0x74, 0xb6, 0xc6, 0xfc, 0xbb, 0x01, 0x67, 0xc9, 0xe2, 0xf8, 0x68, 0x3c,
	0x25, 0xca, 0x64, 0x4a, 0x94, 0xf9, 0x94, 0xa0, 0x87, 0x94, 0xa0, 0x97, 0x94, 0xa0, 0xb7, 0x94,
	0xa0, 0x71, 0x4a, 0xd0, 0x7b, 0x4a, 0xd0, 0x47, 0x4a, 0x94, 0x79, 0x4a, 0xd0, 0xe3, 0x8c, 0x28,
	0xe3, 0x19, 0x51, 0x26, 0x33, 0xa2, 0x38, 0x15, 0xf9, 0x2e, 0x1c, 0x7e, 0x06, 0x00, 0x00, 0xff,
	0xff, 0x49, 0x5d, 0x21, 0xea, 0x45, 0x04, 0x00, 0x00,
}

func (this *AccumulatorProof) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccumulatorProof)
	if !ok {
		that2, ok := that.(AccumulatorProof)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Bitmap != that1.Bitmap {
		return false
	}
	if len(this.NonDefaultSiblings) != len(that1.NonDefaultSiblings) {
		return false
	}
	for i := range this.NonDefaultSiblings {
		if !bytes.Equal(this.NonDefaultSiblings[i], that1.NonDefaultSiblings[i]) {
			return false
		}
	}
	return true
}
func (this *SparseMerkleProof) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SparseMerkleProof)
	if !ok {
		that2, ok := that.(SparseMerkleProof)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Leaf, that1.Leaf) {
		return false
	}
	if !bytes.Equal(this.Bitmap, that1.Bitmap) {
		return false
	}
	if len(this.NonDefaultSiblings) != len(that1.NonDefaultSiblings) {
		return false
	}
	for i := range this.NonDefaultSiblings {
		if !bytes.Equal(this.NonDefaultSiblings[i], that1.NonDefaultSiblings[i]) {
			return false
		}
	}
	return true
}
func (this *SignedTransactionProof) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SignedTransactionProof)
	if !ok {
		that2, ok := that.(SignedTransactionProof)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LedgerInfoToTransactionInfoProof.Equal(that1.LedgerInfoToTransactionInfoProof) {
		return false
	}
	if !this.TransactionInfo.Equal(that1.TransactionInfo) {
		return false
	}
	return true
}
func (this *AccountStateProof) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccountStateProof)
	if !ok {
		that2, ok := that.(AccountStateProof)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LedgerInfoToTransactionInfoProof.Equal(that1.LedgerInfoToTransactionInfoProof) {
		return false
	}
	if !this.TransactionInfo.Equal(that1.TransactionInfo) {
		return false
	}
	if !this.TransactionInfoToAccountProof.Equal(that1.TransactionInfoToAccountProof) {
		return false
	}
	return true
}
func (this *EventProof) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventProof)
	if !ok {
		that2, ok := that.(EventProof)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LedgerInfoToTransactionInfoProof.Equal(that1.LedgerInfoToTransactionInfoProof) {
		return false
	}
	if !this.TransactionInfo.Equal(that1.TransactionInfo) {
		return false
	}
	if !this.TransactionInfoToEventProof.Equal(that1.TransactionInfoToEventProof) {
		return false
	}
	return true
}
func (this *AccumulatorProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&types.AccumulatorProof{")
	s = append(s, "Bitmap: "+fmt.Sprintf("%#v", this.Bitmap)+",\n")
	s = append(s, "NonDefaultSiblings: "+fmt.Sprintf("%#v", this.NonDefaultSiblings)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SparseMerkleProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.SparseMerkleProof{")
	s = append(s, "Leaf: "+fmt.Sprintf("%#v", this.Leaf)+",\n")
	s = append(s, "Bitmap: "+fmt.Sprintf("%#v", this.Bitmap)+",\n")
	s = append(s, "NonDefaultSiblings: "+fmt.Sprintf("%#v", this.NonDefaultSiblings)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SignedTransactionProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&types.SignedTransactionProof{")
	if this.LedgerInfoToTransactionInfoProof != nil {
		s = append(s, "LedgerInfoToTransactionInfoProof: "+fmt.Sprintf("%#v", this.LedgerInfoToTransactionInfoProof)+",\n")
	}
	if this.TransactionInfo != nil {
		s = append(s, "TransactionInfo: "+fmt.Sprintf("%#v", this.TransactionInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AccountStateProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.AccountStateProof{")
	if this.LedgerInfoToTransactionInfoProof != nil {
		s = append(s, "LedgerInfoToTransactionInfoProof: "+fmt.Sprintf("%#v", this.LedgerInfoToTransactionInfoProof)+",\n")
	}
	if this.TransactionInfo != nil {
		s = append(s, "TransactionInfo: "+fmt.Sprintf("%#v", this.TransactionInfo)+",\n")
	}
	if this.TransactionInfoToAccountProof != nil {
		s = append(s, "TransactionInfoToAccountProof: "+fmt.Sprintf("%#v", this.TransactionInfoToAccountProof)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EventProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.EventProof{")
	if this.LedgerInfoToTransactionInfoProof != nil {
		s = append(s, "LedgerInfoToTransactionInfoProof: "+fmt.Sprintf("%#v", this.LedgerInfoToTransactionInfoProof)+",\n")
	}
	if this.TransactionInfo != nil {
		s = append(s, "TransactionInfo: "+fmt.Sprintf("%#v", this.TransactionInfo)+",\n")
	}
	if this.TransactionInfoToEventProof != nil {
		s = append(s, "TransactionInfoToEventProof: "+fmt.Sprintf("%#v", this.TransactionInfoToEventProof)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringProof(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *AccumulatorProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccumulatorProof) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bitmap != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintProof(dAtA, i, uint64(m.Bitmap))
	}
	if len(m.NonDefaultSiblings) > 0 {
		for _, b := range m.NonDefaultSiblings {
			dAtA[i] = 0x12
			i++
			i = encodeVarintProof(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *SparseMerkleProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SparseMerkleProof) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Leaf) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProof(dAtA, i, uint64(len(m.Leaf)))
		i += copy(dAtA[i:], m.Leaf)
	}
	if len(m.Bitmap) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProof(dAtA, i, uint64(len(m.Bitmap)))
		i += copy(dAtA[i:], m.Bitmap)
	}
	if len(m.NonDefaultSiblings) > 0 {
		for _, b := range m.NonDefaultSiblings {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintProof(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *SignedTransactionProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedTransactionProof) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LedgerInfoToTransactionInfoProof != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProof(dAtA, i, uint64(m.LedgerInfoToTransactionInfoProof.Size()))
		n1, err1 := m.LedgerInfoToTransactionInfoProof.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if m.TransactionInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProof(dAtA, i, uint64(m.TransactionInfo.Size()))
		n2, err2 := m.TransactionInfo.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	return i, nil
}

func (m *AccountStateProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountStateProof) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LedgerInfoToTransactionInfoProof != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProof(dAtA, i, uint64(m.LedgerInfoToTransactionInfoProof.Size()))
		n3, err3 := m.LedgerInfoToTransactionInfoProof.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if m.TransactionInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProof(dAtA, i, uint64(m.TransactionInfo.Size()))
		n4, err4 := m.TransactionInfo.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	if m.TransactionInfoToAccountProof != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProof(dAtA, i, uint64(m.TransactionInfoToAccountProof.Size()))
		n5, err5 := m.TransactionInfoToAccountProof.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	return i, nil
}

func (m *EventProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventProof) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LedgerInfoToTransactionInfoProof != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProof(dAtA, i, uint64(m.LedgerInfoToTransactionInfoProof.Size()))
		n6, err6 := m.LedgerInfoToTransactionInfoProof.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	if m.TransactionInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProof(dAtA, i, uint64(m.TransactionInfo.Size()))
		n7, err7 := m.TransactionInfo.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += n7
	}
	if m.TransactionInfoToEventProof != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProof(dAtA, i, uint64(m.TransactionInfoToEventProof.Size()))
		n8, err8 := m.TransactionInfoToEventProof.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	return i, nil
}

func encodeVarintProof(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AccumulatorProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bitmap != 0 {
		n += 1 + sovProof(uint64(m.Bitmap))
	}
	if len(m.NonDefaultSiblings) > 0 {
		for _, b := range m.NonDefaultSiblings {
			l = len(b)
			n += 1 + l + sovProof(uint64(l))
		}
	}
	return n
}

func (m *SparseMerkleProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Leaf)
	if l > 0 {
		n += 1 + l + sovProof(uint64(l))
	}
	l = len(m.Bitmap)
	if l > 0 {
		n += 1 + l + sovProof(uint64(l))
	}
	if len(m.NonDefaultSiblings) > 0 {
		for _, b := range m.NonDefaultSiblings {
			l = len(b)
			n += 1 + l + sovProof(uint64(l))
		}
	}
	return n
}

func (m *SignedTransactionProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LedgerInfoToTransactionInfoProof != nil {
		l = m.LedgerInfoToTransactionInfoProof.Size()
		n += 1 + l + sovProof(uint64(l))
	}
	if m.TransactionInfo != nil {
		l = m.TransactionInfo.Size()
		n += 1 + l + sovProof(uint64(l))
	}
	return n
}

func (m *AccountStateProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LedgerInfoToTransactionInfoProof != nil {
		l = m.LedgerInfoToTransactionInfoProof.Size()
		n += 1 + l + sovProof(uint64(l))
	}
	if m.TransactionInfo != nil {
		l = m.TransactionInfo.Size()
		n += 1 + l + sovProof(uint64(l))
	}
	if m.TransactionInfoToAccountProof != nil {
		l = m.TransactionInfoToAccountProof.Size()
		n += 1 + l + sovProof(uint64(l))
	}
	return n
}

func (m *EventProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LedgerInfoToTransactionInfoProof != nil {
		l = m.LedgerInfoToTransactionInfoProof.Size()
		n += 1 + l + sovProof(uint64(l))
	}
	if m.TransactionInfo != nil {
		l = m.TransactionInfo.Size()
		n += 1 + l + sovProof(uint64(l))
	}
	if m.TransactionInfoToEventProof != nil {
		l = m.TransactionInfoToEventProof.Size()
		n += 1 + l + sovProof(uint64(l))
	}
	return n
}

func sovProof(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProof(x uint64) (n int) {
	return sovProof(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AccumulatorProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AccumulatorProof{`,
		`Bitmap:` + fmt.Sprintf("%v", this.Bitmap) + `,`,
		`NonDefaultSiblings:` + fmt.Sprintf("%v", this.NonDefaultSiblings) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SparseMerkleProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SparseMerkleProof{`,
		`Leaf:` + fmt.Sprintf("%v", this.Leaf) + `,`,
		`Bitmap:` + fmt.Sprintf("%v", this.Bitmap) + `,`,
		`NonDefaultSiblings:` + fmt.Sprintf("%v", this.NonDefaultSiblings) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignedTransactionProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SignedTransactionProof{`,
		`LedgerInfoToTransactionInfoProof:` + strings.Replace(this.LedgerInfoToTransactionInfoProof.String(), "AccumulatorProof", "AccumulatorProof", 1) + `,`,
		`TransactionInfo:` + strings.Replace(fmt.Sprintf("%v", this.TransactionInfo), "TransactionInfo", "TransactionInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AccountStateProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AccountStateProof{`,
		`LedgerInfoToTransactionInfoProof:` + strings.Replace(this.LedgerInfoToTransactionInfoProof.String(), "AccumulatorProof", "AccumulatorProof", 1) + `,`,
		`TransactionInfo:` + strings.Replace(fmt.Sprintf("%v", this.TransactionInfo), "TransactionInfo", "TransactionInfo", 1) + `,`,
		`TransactionInfoToAccountProof:` + strings.Replace(this.TransactionInfoToAccountProof.String(), "SparseMerkleProof", "SparseMerkleProof", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EventProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EventProof{`,
		`LedgerInfoToTransactionInfoProof:` + strings.Replace(this.LedgerInfoToTransactionInfoProof.String(), "AccumulatorProof", "AccumulatorProof", 1) + `,`,
		`TransactionInfo:` + strings.Replace(fmt.Sprintf("%v", this.TransactionInfo), "TransactionInfo", "TransactionInfo", 1) + `,`,
		`TransactionInfoToEventProof:` + strings.Replace(this.TransactionInfoToEventProof.String(), "AccumulatorProof", "AccumulatorProof", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringProof(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AccumulatorProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccumulatorProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccumulatorProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bitmap", wireType)
			}
			m.Bitmap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bitmap |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonDefaultSiblings", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NonDefaultSiblings = append(m.NonDefaultSiblings, make([]byte, postIndex-iNdEx))
			copy(m.NonDefaultSiblings[len(m.NonDefaultSiblings)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProof
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SparseMerkleProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SparseMerkleProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SparseMerkleProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leaf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leaf = append(m.Leaf[:0], dAtA[iNdEx:postIndex]...)
			if m.Leaf == nil {
				m.Leaf = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bitmap", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bitmap = append(m.Bitmap[:0], dAtA[iNdEx:postIndex]...)
			if m.Bitmap == nil {
				m.Bitmap = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonDefaultSiblings", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NonDefaultSiblings = append(m.NonDefaultSiblings, make([]byte, postIndex-iNdEx))
			copy(m.NonDefaultSiblings[len(m.NonDefaultSiblings)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProof
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedTransactionProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedTransactionProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedTransactionProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerInfoToTransactionInfoProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LedgerInfoToTransactionInfoProof == nil {
				m.LedgerInfoToTransactionInfoProof = &AccumulatorProof{}
			}
			if err := m.LedgerInfoToTransactionInfoProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionInfo == nil {
				m.TransactionInfo = &TransactionInfo{}
			}
			if err := m.TransactionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProof
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountStateProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountStateProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountStateProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerInfoToTransactionInfoProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LedgerInfoToTransactionInfoProof == nil {
				m.LedgerInfoToTransactionInfoProof = &AccumulatorProof{}
			}
			if err := m.LedgerInfoToTransactionInfoProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionInfo == nil {
				m.TransactionInfo = &TransactionInfo{}
			}
			if err := m.TransactionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionInfoToAccountProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionInfoToAccountProof == nil {
				m.TransactionInfoToAccountProof = &SparseMerkleProof{}
			}
			if err := m.TransactionInfoToAccountProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProof
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerInfoToTransactionInfoProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LedgerInfoToTransactionInfoProof == nil {
				m.LedgerInfoToTransactionInfoProof = &AccumulatorProof{}
			}
			if err := m.LedgerInfoToTransactionInfoProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionInfo == nil {
				m.TransactionInfo = &TransactionInfo{}
			}
			if err := m.TransactionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionInfoToEventProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionInfoToEventProof == nil {
				m.TransactionInfoToEventProof = &AccumulatorProof{}
			}
			if err := m.TransactionInfoToEventProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProof
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProof(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProof
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProof
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProof
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProof
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthProof
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProof
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProof(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthProof
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProof = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProof   = fmt.Errorf("proto: integer overflow")
)
