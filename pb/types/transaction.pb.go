// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: transaction.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Type of write operation
type WriteOpType int32

const (
	// The WriteOp is to create/update the field from storage.
	Write WriteOpType = 0
	// The WriteOp is to delete the field from storage.
	Delete WriteOpType = 1
)

var WriteOpType_name = map[int32]string{
	0: "Write",
	1: "Delete",
}

var WriteOpType_value = map[string]int32{
	"Write":  0,
	"Delete": 1,
}

func (WriteOpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2cc4e03d2c28c490, []int{0}
}

type TransactionArgument_ArgType int32

const (
	U64       TransactionArgument_ArgType = 0
	ADDRESS   TransactionArgument_ArgType = 1
	STRING    TransactionArgument_ArgType = 2
	BYTEARRAY TransactionArgument_ArgType = 3
)

var TransactionArgument_ArgType_name = map[int32]string{
	0: "U64",
	1: "ADDRESS",
	2: "STRING",
	3: "BYTEARRAY",
}

var TransactionArgument_ArgType_value = map[string]int32{
	"U64":       0,
	"ADDRESS":   1,
	"STRING":    2,
	"BYTEARRAY": 3,
}

func (TransactionArgument_ArgType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2cc4e03d2c28c490, []int{2, 0}
}

// A generic structure that describes a transaction that a client submits
type RawTransaction struct {
	// Sender's account address
	SenderAccount []byte `protobuf:"bytes,1,opt,name=sender_account,json=senderAccount,proto3" json:"sender_account,omitempty"`
	// Sequence number of this transaction corresponding to sender's account.
	SequenceNumber uint64 `protobuf:"varint,2,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	// Types that are valid to be assigned to Payload:
	//	*RawTransaction_Program
	//	*RawTransaction_WriteSet
	Payload isRawTransaction_Payload `protobuf_oneof:"payload"`
	// Maximal total gas specified by wallet to spend for this transaction.
	MaxGasAmount uint64 `protobuf:"varint,5,opt,name=max_gas_amount,json=maxGasAmount,proto3" json:"max_gas_amount,omitempty"`
	// The price to be paid for each unit of gas.
	GasUnitPrice uint64 `protobuf:"varint,6,opt,name=gas_unit_price,json=gasUnitPrice,proto3" json:"gas_unit_price,omitempty"`
	// Expiration time for this transaction.  If storage is queried and
	// the time returned is greater than or equal to this time and this
	// transaction has not been included, you can be certain that it will
	// never be included.
	// If set to 0, there will be no expiration time
	ExpirationTime uint64 `protobuf:"varint,7,opt,name=expiration_time,json=expirationTime,proto3" json:"expiration_time,omitempty"`
}

func (m *RawTransaction) Reset()      { *m = RawTransaction{} }
func (*RawTransaction) ProtoMessage() {}
func (*RawTransaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_2cc4e03d2c28c490, []int{0}
}
func (m *RawTransaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawTransaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawTransaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawTransaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawTransaction.Merge(m, src)
}
func (m *RawTransaction) XXX_Size() int {
	return m.Size()
}
func (m *RawTransaction) XXX_DiscardUnknown() {
	xxx_messageInfo_RawTransaction.DiscardUnknown(m)
}

var xxx_messageInfo_RawTransaction proto.InternalMessageInfo

type isRawTransaction_Payload interface {
	isRawTransaction_Payload()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RawTransaction_Program struct {
	Program *Program `protobuf:"bytes,3,opt,name=program,proto3,oneof"`
}
type RawTransaction_WriteSet struct {
	WriteSet *WriteSet `protobuf:"bytes,4,opt,name=write_set,json=writeSet,proto3,oneof"`
}

func (*RawTransaction_Program) isRawTransaction_Payload()  {}
func (*RawTransaction_WriteSet) isRawTransaction_Payload() {}

func (m *RawTransaction) GetPayload() isRawTransaction_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *RawTransaction) GetSenderAccount() []byte {
	if m != nil {
		return m.SenderAccount
	}
	return nil
}

func (m *RawTransaction) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *RawTransaction) GetProgram() *Program {
	if x, ok := m.GetPayload().(*RawTransaction_Program); ok {
		return x.Program
	}
	return nil
}

func (m *RawTransaction) GetWriteSet() *WriteSet {
	if x, ok := m.GetPayload().(*RawTransaction_WriteSet); ok {
		return x.WriteSet
	}
	return nil
}

func (m *RawTransaction) GetMaxGasAmount() uint64 {
	if m != nil {
		return m.MaxGasAmount
	}
	return 0
}

func (m *RawTransaction) GetGasUnitPrice() uint64 {
	if m != nil {
		return m.GasUnitPrice
	}
	return 0
}

func (m *RawTransaction) GetExpirationTime() uint64 {
	if m != nil {
		return m.ExpirationTime
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RawTransaction) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RawTransaction_OneofMarshaler, _RawTransaction_OneofUnmarshaler, _RawTransaction_OneofSizer, []interface{}{
		(*RawTransaction_Program)(nil),
		(*RawTransaction_WriteSet)(nil),
	}
}

func _RawTransaction_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RawTransaction)
	// payload
	switch x := m.Payload.(type) {
	case *RawTransaction_Program:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Program); err != nil {
			return err
		}
	case *RawTransaction_WriteSet:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.WriteSet); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RawTransaction.Payload has unexpected type %T", x)
	}
	return nil
}

func _RawTransaction_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RawTransaction)
	switch tag {
	case 3: // payload.program
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Program)
		err := b.DecodeMessage(msg)
		m.Payload = &RawTransaction_Program{msg}
		return true, err
	case 4: // payload.write_set
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WriteSet)
		err := b.DecodeMessage(msg)
		m.Payload = &RawTransaction_WriteSet{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RawTransaction_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RawTransaction)
	// payload
	switch x := m.Payload.(type) {
	case *RawTransaction_Program:
		s := proto.Size(x.Program)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RawTransaction_WriteSet:
		s := proto.Size(x.WriteSet)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// The code for the transaction to execute
type Program struct {
	Code      []byte                 `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
	Arguments []*TransactionArgument `protobuf:"bytes,2,rep,name=arguments,proto3" json:"arguments,omitempty"`
	Modules   [][]byte               `protobuf:"bytes,3,rep,name=modules,proto3" json:"modules,omitempty"`
}

func (m *Program) Reset()      { *m = Program{} }
func (*Program) ProtoMessage() {}
func (*Program) Descriptor() ([]byte, []int) {
	return fileDescriptor_2cc4e03d2c28c490, []int{1}
}
func (m *Program) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Program) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Program.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Program) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Program.Merge(m, src)
}
func (m *Program) XXX_Size() int {
	return m.Size()
}
func (m *Program) XXX_DiscardUnknown() {
	xxx_messageInfo_Program.DiscardUnknown(m)
}

var xxx_messageInfo_Program proto.InternalMessageInfo

func (m *Program) GetCode() []byte {
	if m != nil {
		return m.Code
	}
	return nil
}

func (m *Program) GetArguments() []*TransactionArgument {
	if m != nil {
		return m.Arguments
	}
	return nil
}

func (m *Program) GetModules() [][]byte {
	if m != nil {
		return m.Modules
	}
	return nil
}

// An argument to the transaction if the transaction takes arguments
type TransactionArgument struct {
	Type TransactionArgument_ArgType `protobuf:"varint,1,opt,name=type,proto3,enum=types.TransactionArgument_ArgType" json:"type,omitempty"`
	Data []byte                      `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *TransactionArgument) Reset()      { *m = TransactionArgument{} }
func (*TransactionArgument) ProtoMessage() {}
func (*TransactionArgument) Descriptor() ([]byte, []int) {
	return fileDescriptor_2cc4e03d2c28c490, []int{2}
}
func (m *TransactionArgument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionArgument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionArgument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionArgument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionArgument.Merge(m, src)
}
func (m *TransactionArgument) XXX_Size() int {
	return m.Size()
}
func (m *TransactionArgument) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionArgument.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionArgument proto.InternalMessageInfo

func (m *TransactionArgument) GetType() TransactionArgument_ArgType {
	if m != nil {
		return m.Type
	}
	return U64
}

func (m *TransactionArgument) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// A generic structure that represents signed RawTransaction
type SignedTransaction struct {
	// The serialized Protobuf bytes for RawTransaction, for which the signature
	// was signed. Protobuf doesn't guarantee the serialized bytes is canonical
	// across different language implementations, but for our use cases for
	// transaction it is not necessary because the client is the only one to
	// produce this bytes, which is then persisted in storage.
	RawTxnBytes []byte `protobuf:"bytes,1,opt,name=raw_txn_bytes,json=rawTxnBytes,proto3" json:"raw_txn_bytes,omitempty"`
	// public key that corresponds to RawTransaction::sender_account
	SenderPublicKey []byte `protobuf:"bytes,2,opt,name=sender_public_key,json=senderPublicKey,proto3" json:"sender_public_key,omitempty"`
	// signature for the hash
	SenderSignature []byte `protobuf:"bytes,3,opt,name=sender_signature,json=senderSignature,proto3" json:"sender_signature,omitempty"`
}

func (m *SignedTransaction) Reset()      { *m = SignedTransaction{} }
func (*SignedTransaction) ProtoMessage() {}
func (*SignedTransaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_2cc4e03d2c28c490, []int{3}
}
func (m *SignedTransaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedTransaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignedTransaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignedTransaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedTransaction.Merge(m, src)
}
func (m *SignedTransaction) XXX_Size() int {
	return m.Size()
}
func (m *SignedTransaction) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedTransaction.DiscardUnknown(m)
}

var xxx_messageInfo_SignedTransaction proto.InternalMessageInfo

func (m *SignedTransaction) GetRawTxnBytes() []byte {
	if m != nil {
		return m.RawTxnBytes
	}
	return nil
}

func (m *SignedTransaction) GetSenderPublicKey() []byte {
	if m != nil {
		return m.SenderPublicKey
	}
	return nil
}

func (m *SignedTransaction) GetSenderSignature() []byte {
	if m != nil {
		return m.SenderSignature
	}
	return nil
}

type SignedTransactionWithProof struct {
	// The version of the returned signed transaction.
	Version uint64 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	// The transaction itself.
	SignedTransaction *SignedTransaction `protobuf:"bytes,2,opt,name=signed_transaction,json=signedTransaction,proto3" json:"signed_transaction,omitempty"`
	// The proof authenticating the signed transaction.
	Proof *SignedTransactionProof `protobuf:"bytes,3,opt,name=proof,proto3" json:"proof,omitempty"`
	// The events yielded by executing the transaction, if requested.
	Events *EventsList `protobuf:"bytes,4,opt,name=events,proto3" json:"events,omitempty"`
}

func (m *SignedTransactionWithProof) Reset()      { *m = SignedTransactionWithProof{} }
func (*SignedTransactionWithProof) ProtoMessage() {}
func (*SignedTransactionWithProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_2cc4e03d2c28c490, []int{4}
}
func (m *SignedTransactionWithProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedTransactionWithProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignedTransactionWithProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignedTransactionWithProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedTransactionWithProof.Merge(m, src)
}
func (m *SignedTransactionWithProof) XXX_Size() int {
	return m.Size()
}
func (m *SignedTransactionWithProof) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedTransactionWithProof.DiscardUnknown(m)
}

var xxx_messageInfo_SignedTransactionWithProof proto.InternalMessageInfo

func (m *SignedTransactionWithProof) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *SignedTransactionWithProof) GetSignedTransaction() *SignedTransaction {
	if m != nil {
		return m.SignedTransaction
	}
	return nil
}

func (m *SignedTransactionWithProof) GetProof() *SignedTransactionProof {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *SignedTransactionWithProof) GetEvents() *EventsList {
	if m != nil {
		return m.Events
	}
	return nil
}

// A generic structure that represents a block of transactions originated from a
// particular validator instance.
type SignedTransactionsBlock struct {
	// Set of Signed Transactions
	Transactions []*SignedTransaction `protobuf:"bytes,1,rep,name=transactions,proto3" json:"transactions,omitempty"`
	// Public key of the validator that created this block
	ValidatorPublicKey []byte `protobuf:"bytes,2,opt,name=validator_public_key,json=validatorPublicKey,proto3" json:"validator_public_key,omitempty"`
	// Signature of the validator that created this block
	ValidatorSignature []byte `protobuf:"bytes,3,opt,name=validator_signature,json=validatorSignature,proto3" json:"validator_signature,omitempty"`
}

func (m *SignedTransactionsBlock) Reset()      { *m = SignedTransactionsBlock{} }
func (*SignedTransactionsBlock) ProtoMessage() {}
func (*SignedTransactionsBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_2cc4e03d2c28c490, []int{5}
}
func (m *SignedTransactionsBlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedTransactionsBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignedTransactionsBlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignedTransactionsBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedTransactionsBlock.Merge(m, src)
}
func (m *SignedTransactionsBlock) XXX_Size() int {
	return m.Size()
}
func (m *SignedTransactionsBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedTransactionsBlock.DiscardUnknown(m)
}

var xxx_messageInfo_SignedTransactionsBlock proto.InternalMessageInfo

func (m *SignedTransactionsBlock) GetTransactions() []*SignedTransaction {
	if m != nil {
		return m.Transactions
	}
	return nil
}

func (m *SignedTransactionsBlock) GetValidatorPublicKey() []byte {
	if m != nil {
		return m.ValidatorPublicKey
	}
	return nil
}

func (m *SignedTransactionsBlock) GetValidatorSignature() []byte {
	if m != nil {
		return m.ValidatorSignature
	}
	return nil
}

// Set of WriteOps to save to storage.
type WriteSet struct {
	// Set of WriteOp for storage update.
	WriteSet []*WriteOp `protobuf:"bytes,1,rep,name=write_set,json=writeSet,proto3" json:"write_set,omitempty"`
}

func (m *WriteSet) Reset()      { *m = WriteSet{} }
func (*WriteSet) ProtoMessage() {}
func (*WriteSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_2cc4e03d2c28c490, []int{6}
}
func (m *WriteSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteSet.Merge(m, src)
}
func (m *WriteSet) XXX_Size() int {
	return m.Size()
}
func (m *WriteSet) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteSet.DiscardUnknown(m)
}

var xxx_messageInfo_WriteSet proto.InternalMessageInfo

func (m *WriteSet) GetWriteSet() []*WriteOp {
	if m != nil {
		return m.WriteSet
	}
	return nil
}

// Write Operation on underlying storage.
type WriteOp struct {
	// AccessPath of the write set.
	AccessPath *AccessPath `protobuf:"bytes,1,opt,name=access_path,json=accessPath,proto3" json:"access_path,omitempty"`
	// The value of the write op. Empty if `type` is Delete.
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// WriteOp type.
	Type WriteOpType `protobuf:"varint,3,opt,name=type,proto3,enum=types.WriteOpType" json:"type,omitempty"`
}

func (m *WriteOp) Reset()      { *m = WriteOp{} }
func (*WriteOp) ProtoMessage() {}
func (*WriteOp) Descriptor() ([]byte, []int) {
	return fileDescriptor_2cc4e03d2c28c490, []int{7}
}
func (m *WriteOp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteOp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteOp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WriteOp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteOp.Merge(m, src)
}
func (m *WriteOp) XXX_Size() int {
	return m.Size()
}
func (m *WriteOp) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteOp.DiscardUnknown(m)
}

var xxx_messageInfo_WriteOp proto.InternalMessageInfo

func (m *WriteOp) GetAccessPath() *AccessPath {
	if m != nil {
		return m.AccessPath
	}
	return nil
}

func (m *WriteOp) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *WriteOp) GetType() WriteOpType {
	if m != nil {
		return m.Type
	}
	return Write
}

// Account state as a whole.
// After execution, updates to accounts are passed in this form to storage for
// persistence.
type AccountState struct {
	// Account address
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Account state blob
	Blob []byte `protobuf:"bytes,2,opt,name=blob,proto3" json:"blob,omitempty"`
}

func (m *AccountState) Reset()      { *m = AccountState{} }
func (*AccountState) ProtoMessage() {}
func (*AccountState) Descriptor() ([]byte, []int) {
	return fileDescriptor_2cc4e03d2c28c490, []int{8}
}
func (m *AccountState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountState.Merge(m, src)
}
func (m *AccountState) XXX_Size() int {
	return m.Size()
}
func (m *AccountState) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountState.DiscardUnknown(m)
}

var xxx_messageInfo_AccountState proto.InternalMessageInfo

func (m *AccountState) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *AccountState) GetBlob() []byte {
	if m != nil {
		return m.Blob
	}
	return nil
}

// Transaction struct to commit to storage
type TransactionToCommit struct {
	// The signed transaction which was executed
	SignedTxn *SignedTransaction `protobuf:"bytes,1,opt,name=signed_txn,json=signedTxn,proto3" json:"signed_txn,omitempty"`
	// State db updates
	AccountStates []*AccountState `protobuf:"bytes,2,rep,name=account_states,json=accountStates,proto3" json:"account_states,omitempty"`
	// Events yielded by the transaction.
	Events []*Event `protobuf:"bytes,3,rep,name=events,proto3" json:"events,omitempty"`
	// The amount of gas used.
	GasUsed uint64 `protobuf:"varint,4,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
}

func (m *TransactionToCommit) Reset()      { *m = TransactionToCommit{} }
func (*TransactionToCommit) ProtoMessage() {}
func (*TransactionToCommit) Descriptor() ([]byte, []int) {
	return fileDescriptor_2cc4e03d2c28c490, []int{9}
}
func (m *TransactionToCommit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionToCommit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionToCommit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionToCommit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionToCommit.Merge(m, src)
}
func (m *TransactionToCommit) XXX_Size() int {
	return m.Size()
}
func (m *TransactionToCommit) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionToCommit.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionToCommit proto.InternalMessageInfo

func (m *TransactionToCommit) GetSignedTxn() *SignedTransaction {
	if m != nil {
		return m.SignedTxn
	}
	return nil
}

func (m *TransactionToCommit) GetAccountStates() []*AccountState {
	if m != nil {
		return m.AccountStates
	}
	return nil
}

func (m *TransactionToCommit) GetEvents() []*Event {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *TransactionToCommit) GetGasUsed() uint64 {
	if m != nil {
		return m.GasUsed
	}
	return 0
}

// A list of consecutive transactions with proof. This is mainly used for state
// synchronization when a validator would request a list of transactions from a
// peer, verify the proof, execute the transactions and persist them. Note that
// the transactions are supposed to belong to the same epoch E, otherwise
// verification will fail.
type TransactionListWithProof struct {
	// The list of transactions.
	Transactions []*SignedTransaction `protobuf:"bytes,1,rep,name=transactions,proto3" json:"transactions,omitempty"`
	// The list of corresponding TransactionInfo objects.
	Infos []*TransactionInfo `protobuf:"bytes,2,rep,name=infos,proto3" json:"infos,omitempty"`
	// The list of corresponding Event objects (only present if fetch_events was set to true in req)
	EventsForVersions *EventsForVersions `protobuf:"bytes,3,opt,name=events_for_versions,json=eventsForVersions,proto3" json:"events_for_versions,omitempty"`
	// If the list is not empty, the version of the first transaction.
	FirstTransactionVersion *types.UInt64Value `protobuf:"bytes,4,opt,name=first_transaction_version,json=firstTransactionVersion,proto3" json:"first_transaction_version,omitempty"`
	// The proofs of the first and last transaction in this chunk. When this is
	// used for state synchronization, the validator who requests the transactions
	// will provide a version in the request and the proofs will be relative to
	// the given version. When this is returned in GetTransactionsResponse, the
	// proofs will be relative to the ledger info returned in
	// UpdateToLatestLedgerResponse.
	ProofOfFirstTransaction *AccumulatorProof `protobuf:"bytes,5,opt,name=proof_of_first_transaction,json=proofOfFirstTransaction,proto3" json:"proof_of_first_transaction,omitempty"`
	ProofOfLastTransaction  *AccumulatorProof `protobuf:"bytes,6,opt,name=proof_of_last_transaction,json=proofOfLastTransaction,proto3" json:"proof_of_last_transaction,omitempty"`
}

func (m *TransactionListWithProof) Reset()      { *m = TransactionListWithProof{} }
func (*TransactionListWithProof) ProtoMessage() {}
func (*TransactionListWithProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_2cc4e03d2c28c490, []int{10}
}
func (m *TransactionListWithProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionListWithProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionListWithProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactionListWithProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionListWithProof.Merge(m, src)
}
func (m *TransactionListWithProof) XXX_Size() int {
	return m.Size()
}
func (m *TransactionListWithProof) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionListWithProof.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionListWithProof proto.InternalMessageInfo

func (m *TransactionListWithProof) GetTransactions() []*SignedTransaction {
	if m != nil {
		return m.Transactions
	}
	return nil
}

func (m *TransactionListWithProof) GetInfos() []*TransactionInfo {
	if m != nil {
		return m.Infos
	}
	return nil
}

func (m *TransactionListWithProof) GetEventsForVersions() *EventsForVersions {
	if m != nil {
		return m.EventsForVersions
	}
	return nil
}

func (m *TransactionListWithProof) GetFirstTransactionVersion() *types.UInt64Value {
	if m != nil {
		return m.FirstTransactionVersion
	}
	return nil
}

func (m *TransactionListWithProof) GetProofOfFirstTransaction() *AccumulatorProof {
	if m != nil {
		return m.ProofOfFirstTransaction
	}
	return nil
}

func (m *TransactionListWithProof) GetProofOfLastTransaction() *AccumulatorProof {
	if m != nil {
		return m.ProofOfLastTransaction
	}
	return nil
}

func init() {
	proto.RegisterEnum("types.WriteOpType", WriteOpType_name, WriteOpType_value)
	proto.RegisterEnum("types.TransactionArgument_ArgType", TransactionArgument_ArgType_name, TransactionArgument_ArgType_value)
	proto.RegisterType((*RawTransaction)(nil), "types.RawTransaction")
	proto.RegisterType((*Program)(nil), "types.Program")
	proto.RegisterType((*TransactionArgument)(nil), "types.TransactionArgument")
	proto.RegisterType((*SignedTransaction)(nil), "types.SignedTransaction")
	proto.RegisterType((*SignedTransactionWithProof)(nil), "types.SignedTransactionWithProof")
	proto.RegisterType((*SignedTransactionsBlock)(nil), "types.SignedTransactionsBlock")
	proto.RegisterType((*WriteSet)(nil), "types.WriteSet")
	proto.RegisterType((*WriteOp)(nil), "types.WriteOp")
	proto.RegisterType((*AccountState)(nil), "types.AccountState")
	proto.RegisterType((*TransactionToCommit)(nil), "types.TransactionToCommit")
	proto.RegisterType((*TransactionListWithProof)(nil), "types.TransactionListWithProof")
}

func init() { proto.RegisterFile("transaction.proto", fileDescriptor_2cc4e03d2c28c490) }

var fileDescriptor_2cc4e03d2c28c490 = []byte{
	// 1100 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x16, 0x2d, 0xc9, 0x8a, 0x46, 0xb2, 0x22, 0xad, 0x83, 0x98, 0x36, 0x5a, 0xc2, 0x20, 0xdc,
	0xd6, 0x71, 0x0b, 0xb9, 0x50, 0x0c, 0xa7, 0x08, 0x72, 0x91, 0x6b, 0xc7, 0x36, 0x1a, 0x24, 0xc6,
	0x4a, 0x4e, 0x9a, 0x13, 0xb1, 0x92, 0x56, 0x32, 0x11, 0x91, 0xcb, 0x70, 0x97, 0x96, 0x84, 0x5e,
	0xfa, 0x04, 0x45, 0x5f, 0xa0, 0xf7, 0x3e, 0x43, 0xd1, 0x07, 0x28, 0xd0, 0x8b, 0x0f, 0x3d, 0xe4,
	0xd6, 0x5a, 0xbe, 0xf4, 0x98, 0x47, 0x28, 0xb8, 0x5c, 0x8a, 0xb4, 0x15, 0xe7, 0xd2, 0xdb, 0xce,
	0xec, 0xcc, 0xec, 0xfc, 0x7c, 0xdf, 0x2c, 0xd4, 0x84, 0x4f, 0x5c, 0x4e, 0xba, 0xc2, 0x66, 0x6e,
	0xdd, 0xf3, 0x99, 0x60, 0x28, 0x2f, 0x26, 0x1e, 0xe5, 0x6b, 0x35, 0xd2, 0xed, 0x52, 0xce, 0x2d,
	0x8f, 0x88, 0xb3, 0xe8, 0x66, 0xad, 0x4c, 0xcf, 0xa9, 0x2b, 0xb8, 0x92, 0x4a, 0x9e, 0xcf, 0x58,
	0x5f, 0x09, 0xf7, 0x53, 0x71, 0x2c, 0xdb, 0xed, 0x33, 0xa5, 0x37, 0x06, 0x8c, 0x0d, 0x86, 0x74,
	0x5b, 0x4a, 0x9d, 0xa0, 0xbf, 0x3d, 0xf2, 0x89, 0xe7, 0x51, 0x5f, 0x05, 0x31, 0x7f, 0x5f, 0x80,
	0x0a, 0x26, 0xa3, 0x76, 0xe2, 0x8d, 0x3e, 0x83, 0x0a, 0xa7, 0x6e, 0x8f, 0xfa, 0x16, 0xe9, 0x76,
	0x59, 0xe0, 0x0a, 0x5d, 0x5b, 0xd7, 0x36, 0xcb, 0x78, 0x29, 0xd2, 0x36, 0x23, 0x25, 0xfa, 0x02,
	0xee, 0x72, 0xfa, 0x36, 0xa0, 0x6e, 0x97, 0x5a, 0x6e, 0xe0, 0x74, 0xa8, 0xaf, 0x2f, 0xac, 0x6b,
	0x9b, 0x39, 0x5c, 0x89, 0xd5, 0xcf, 0xa5, 0x16, 0x6d, 0x41, 0xc1, 0xf3, 0xd9, 0xc0, 0x27, 0x8e,
	0x9e, 0x5d, 0xd7, 0x36, 0x4b, 0x8d, 0x4a, 0x5d, 0x56, 0x58, 0x3f, 0x89, 0xb4, 0x47, 0x19, 0x1c,
	0x1b, 0xa0, 0x3a, 0x14, 0x47, 0xbe, 0x2d, 0xa8, 0xc5, 0xa9, 0xd0, 0x73, 0xd2, 0xfa, 0xae, 0xb2,
	0x7e, 0x15, 0xea, 0x5b, 0x54, 0x1c, 0x65, 0xf0, 0x9d, 0x91, 0x3a, 0xa3, 0x0d, 0xa8, 0x38, 0x64,
	0x6c, 0x0d, 0x08, 0xb7, 0x88, 0x23, 0x73, 0xcd, 0xcb, 0x1c, 0xca, 0x0e, 0x19, 0x1f, 0x12, 0xde,
	0x94, 0xba, 0xd0, 0x2a, 0xb4, 0x08, 0x5c, 0x5b, 0x58, 0x9e, 0x6f, 0x77, 0xa9, 0xbe, 0x18, 0x59,
	0x0d, 0x08, 0x3f, 0x75, 0x6d, 0x71, 0x12, 0xea, 0xc2, 0x82, 0xe8, 0xd8, 0xb3, 0x7d, 0x22, 0x7b,
	0x28, 0x6c, 0x87, 0xea, 0x85, 0xa8, 0xa0, 0x44, 0xdd, 0xb6, 0x1d, 0xba, 0x57, 0x84, 0x82, 0x47,
	0x26, 0x43, 0x46, 0x7a, 0xe6, 0x5b, 0x28, 0xa8, 0x2a, 0x10, 0x82, 0x5c, 0x97, 0xf5, 0xa8, 0x6a,
	0x96, 0x3c, 0xa3, 0x6f, 0xa0, 0x48, 0xfc, 0x41, 0xe0, 0x84, 0x53, 0xd3, 0x17, 0xd6, 0xb3, 0x9b,
	0xa5, 0xc6, 0x9a, 0x2a, 0x27, 0xd5, 0xf1, 0xa6, 0x32, 0xc1, 0x89, 0x31, 0xd2, 0xa1, 0xe0, 0xb0,
	0x5e, 0x30, 0xa4, 0x5c, 0xcf, 0xae, 0x67, 0x37, 0xcb, 0x38, 0x16, 0xcd, 0x5f, 0x34, 0x58, 0xfe,
	0x80, 0x33, 0xda, 0x85, 0x5c, 0x18, 0x59, 0xbe, 0x5f, 0x69, 0x98, 0xb7, 0x3f, 0x53, 0x6f, 0xfa,
	0x83, 0xf6, 0xc4, 0xa3, 0x58, 0xda, 0x87, 0x79, 0xf7, 0x88, 0x20, 0x72, 0x78, 0x65, 0x2c, 0xcf,
	0xe6, 0x63, 0x28, 0x28, 0x23, 0x54, 0x80, 0xec, 0xe9, 0xee, 0x4e, 0x35, 0x83, 0x4a, 0x50, 0x68,
	0xee, 0xef, 0xe3, 0x83, 0x56, 0xab, 0xaa, 0x21, 0x80, 0xc5, 0x56, 0x1b, 0x1f, 0x3f, 0x3f, 0xac,
	0x2e, 0xa0, 0x25, 0x28, 0xee, 0xbd, 0x6e, 0x1f, 0x34, 0x31, 0x6e, 0xbe, 0xae, 0x66, 0xcd, 0x9f,
	0x34, 0xa8, 0xb5, 0xec, 0x81, 0x4b, 0x7b, 0x69, 0x50, 0x99, 0xb0, 0xe4, 0x93, 0x91, 0x25, 0xc6,
	0xae, 0xd5, 0x99, 0x08, 0xca, 0x55, 0x9b, 0x4a, 0x3e, 0x19, 0xb5, 0xc7, 0xee, 0x5e, 0xa8, 0x42,
	0x5b, 0x50, 0x53, 0xc0, 0xf3, 0x82, 0xce, 0xd0, 0xee, 0x5a, 0x6f, 0xe8, 0x44, 0xa5, 0x75, 0x37,
	0xba, 0x38, 0x91, 0xfa, 0xef, 0xe8, 0x04, 0x3d, 0x80, 0xaa, 0xb2, 0xe5, 0xf6, 0xc0, 0x25, 0x22,
	0xf0, 0xa9, 0x44, 0xd7, 0xcc, 0xb4, 0x15, 0xab, 0xcd, 0xbf, 0x35, 0x58, 0x9b, 0x4b, 0xe8, 0x95,
	0x2d, 0xce, 0x4e, 0x42, 0xfe, 0x84, 0x9d, 0x3e, 0xa7, 0x3e, 0xb7, 0x99, 0x2b, 0x73, 0xca, 0xe1,
	0x58, 0x44, 0x87, 0x80, 0xb8, 0xf4, 0xb3, 0x52, 0xe4, 0x92, 0x09, 0x95, 0x1a, 0xba, 0xea, 0xef,
	0x5c, 0x60, 0x5c, 0xe3, 0x73, 0xc5, 0x3f, 0x84, 0xbc, 0xe4, 0xaa, 0xc2, 0xff, 0xa7, 0xb7, 0xf9,
	0xca, 0x84, 0x70, 0x64, 0x8b, 0x1e, 0xc0, 0x62, 0x44, 0x77, 0xc5, 0x83, 0x9a, 0xf2, 0x3a, 0x90,
	0xca, 0x67, 0x36, 0x17, 0x58, 0x19, 0x98, 0xbf, 0x69, 0xb0, 0x32, 0x17, 0x8c, 0xef, 0x0d, 0x59,
	0xf7, 0x0d, 0x7a, 0x02, 0xe5, 0x54, 0xf6, 0x61, 0xdf, 0xb3, 0x1f, 0x4d, 0xff, 0x9a, 0x35, 0xfa,
	0x1a, 0xee, 0x9d, 0x93, 0xa1, 0xdd, 0x23, 0x82, 0x7d, 0x60, 0x2a, 0x68, 0x76, 0x97, 0x0c, 0x66,
	0x1b, 0x96, 0x13, 0x8f, 0x9b, 0xb3, 0x49, 0x1c, 0x92, 0xf1, 0x3c, 0x82, 0x3b, 0x31, 0xb5, 0xd1,
	0x97, 0x69, 0xfa, 0x47, 0x99, 0x56, 0xd2, 0xf4, 0x7f, 0xe1, 0x25, 0xdc, 0x37, 0x7f, 0x80, 0x82,
	0x52, 0xa2, 0x06, 0x94, 0x52, 0xdb, 0x52, 0xce, 0x31, 0x69, 0x58, 0x53, 0xde, 0x9c, 0x10, 0x71,
	0x86, 0x81, 0xcc, 0xce, 0xe8, 0x1e, 0xe4, 0xcf, 0xc9, 0x30, 0xa0, 0xaa, 0x96, 0x48, 0x40, 0x9f,
	0x2b, 0x16, 0x65, 0x25, 0x8b, 0xd0, 0xf5, 0xc7, 0x13, 0xd6, 0x98, 0x4f, 0xa0, 0xac, 0x16, 0x61,
	0x4b, 0x10, 0x41, 0x43, 0x14, 0x91, 0x5e, 0xcf, 0xa7, 0x3c, 0x46, 0x76, 0x2c, 0x86, 0xfc, 0xea,
	0x0c, 0x59, 0x27, 0xe6, 0x57, 0x78, 0x36, 0xff, 0xbc, 0xce, 0xe1, 0x36, 0xfb, 0x96, 0x39, 0x8e,
	0x2d, 0xd0, 0x23, 0x80, 0x18, 0x71, 0x63, 0x57, 0x95, 0x71, 0xfb, 0xa8, 0x8a, 0x0a, 0x69, 0x63,
	0x17, 0x3d, 0x86, 0x8a, 0x5a, 0xd6, 0x16, 0x0f, 0xf3, 0x89, 0xb7, 0xcd, 0x72, 0xd2, 0x83, 0x59,
	0xae, 0x78, 0x89, 0xa4, 0x24, 0x8e, 0x36, 0x66, 0x40, 0xcb, 0x4a, 0x9f, 0x72, 0x1a, 0x68, 0x31,
	0xc6, 0xd0, 0x2a, 0xdc, 0x91, 0x3b, 0x94, 0xd3, 0x9e, 0x04, 0x64, 0x0e, 0x17, 0xc2, 0xed, 0xc9,
	0x69, 0xcf, 0xfc, 0x2b, 0x0b, 0x7a, 0x2a, 0xaf, 0x10, 0x9a, 0x09, 0xbd, 0xfe, 0x1f, 0xfe, 0xbe,
	0x82, 0x7c, 0xf8, 0x99, 0xc5, 0xe5, 0xdc, 0x9f, 0xdf, 0x6a, 0xc7, 0x6e, 0x9f, 0xe1, 0xc8, 0x08,
	0x1d, 0xc1, 0x72, 0x94, 0xad, 0xd5, 0x67, 0xbe, 0xa5, 0x68, 0xcc, 0x15, 0xeb, 0xf4, 0x6b, 0xfc,
	0x79, 0xca, 0xfc, 0x97, 0xea, 0x1e, 0xd7, 0xe8, 0x4d, 0x15, 0xfa, 0x1e, 0x56, 0xfb, 0xb6, 0xcf,
	0x45, 0x9a, 0xf9, 0x71, 0x40, 0xc5, 0xc7, 0x4f, 0xea, 0xd1, 0xd7, 0x5a, 0x8f, 0xbf, 0xd6, 0xfa,
	0xe9, 0xb1, 0x2b, 0x76, 0x77, 0x5e, 0x86, 0x38, 0xc2, 0x2b, 0xd2, 0x3d, 0x95, 0xa7, 0x0a, 0x8d,
	0xda, 0xb0, 0x26, 0xf9, 0x6d, 0xb1, 0xbe, 0x35, 0xf7, 0x84, 0xfc, 0xbd, 0x4a, 0x8d, 0x95, 0x64,
	0x6a, 0x81, 0x13, 0x0c, 0x25, 0xc1, 0xe4, 0x6a, 0x58, 0x91, 0xae, 0x2f, 0xfa, 0x4f, 0x6f, 0x04,
	0x47, 0x18, 0x56, 0x67, 0x51, 0x87, 0xe4, 0x46, 0xd0, 0xc5, 0x8f, 0x07, 0xbd, 0xaf, 0x82, 0x3e,
	0x23, 0xd7, 0x62, 0x6e, 0x6d, 0x40, 0x29, 0x85, 0x7b, 0x54, 0x84, 0xbc, 0x14, 0xab, 0x99, 0x70,
	0xfb, 0xef, 0xd3, 0x21, 0x15, 0xb4, 0xaa, 0xed, 0xed, 0x5c, 0x5c, 0x1a, 0x99, 0x77, 0x97, 0x46,
	0xe6, 0xfd, 0xa5, 0xa1, 0xfd, 0x38, 0x35, 0xb4, 0x5f, 0xa7, 0x86, 0xf6, 0xc7, 0xd4, 0xd0, 0x2e,
	0xa6, 0x86, 0xf6, 0xcf, 0xd4, 0xd0, 0xfe, 0x9d, 0x1a, 0x99, 0xf7, 0x53, 0x43, 0xfb, 0xf9, 0xca,
	0xc8, 0x5c, 0x5c, 0x19, 0x99, 0x77, 0x57, 0x46, 0xa6, 0xb3, 0x28, 0x9b, 0xf6, 0xf0, 0xbf, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xb8, 0xe8, 0xe9, 0xa1, 0xff, 0x08, 0x00, 0x00,
}

func (x WriteOpType) String() string {
	s, ok := WriteOpType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TransactionArgument_ArgType) String() string {
	s, ok := TransactionArgument_ArgType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *RawTransaction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RawTransaction)
	if !ok {
		that2, ok := that.(RawTransaction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.SenderAccount, that1.SenderAccount) {
		return false
	}
	if this.SequenceNumber != that1.SequenceNumber {
		return false
	}
	if that1.Payload == nil {
		if this.Payload != nil {
			return false
		}
	} else if this.Payload == nil {
		return false
	} else if !this.Payload.Equal(that1.Payload) {
		return false
	}
	if this.MaxGasAmount != that1.MaxGasAmount {
		return false
	}
	if this.GasUnitPrice != that1.GasUnitPrice {
		return false
	}
	if this.ExpirationTime != that1.ExpirationTime {
		return false
	}
	return true
}
func (this *RawTransaction_Program) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RawTransaction_Program)
	if !ok {
		that2, ok := that.(RawTransaction_Program)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Program.Equal(that1.Program) {
		return false
	}
	return true
}
func (this *RawTransaction_WriteSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RawTransaction_WriteSet)
	if !ok {
		that2, ok := that.(RawTransaction_WriteSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.WriteSet.Equal(that1.WriteSet) {
		return false
	}
	return true
}
func (this *Program) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Program)
	if !ok {
		that2, ok := that.(Program)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Code, that1.Code) {
		return false
	}
	if len(this.Arguments) != len(that1.Arguments) {
		return false
	}
	for i := range this.Arguments {
		if !this.Arguments[i].Equal(that1.Arguments[i]) {
			return false
		}
	}
	if len(this.Modules) != len(that1.Modules) {
		return false
	}
	for i := range this.Modules {
		if !bytes.Equal(this.Modules[i], that1.Modules[i]) {
			return false
		}
	}
	return true
}
func (this *TransactionArgument) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TransactionArgument)
	if !ok {
		that2, ok := that.(TransactionArgument)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *SignedTransaction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SignedTransaction)
	if !ok {
		that2, ok := that.(SignedTransaction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.RawTxnBytes, that1.RawTxnBytes) {
		return false
	}
	if !bytes.Equal(this.SenderPublicKey, that1.SenderPublicKey) {
		return false
	}
	if !bytes.Equal(this.SenderSignature, that1.SenderSignature) {
		return false
	}
	return true
}
func (this *SignedTransactionWithProof) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SignedTransactionWithProof)
	if !ok {
		that2, ok := that.(SignedTransactionWithProof)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.SignedTransaction.Equal(that1.SignedTransaction) {
		return false
	}
	if !this.Proof.Equal(that1.Proof) {
		return false
	}
	if !this.Events.Equal(that1.Events) {
		return false
	}
	return true
}
func (this *SignedTransactionsBlock) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SignedTransactionsBlock)
	if !ok {
		that2, ok := that.(SignedTransactionsBlock)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Transactions) != len(that1.Transactions) {
		return false
	}
	for i := range this.Transactions {
		if !this.Transactions[i].Equal(that1.Transactions[i]) {
			return false
		}
	}
	if !bytes.Equal(this.ValidatorPublicKey, that1.ValidatorPublicKey) {
		return false
	}
	if !bytes.Equal(this.ValidatorSignature, that1.ValidatorSignature) {
		return false
	}
	return true
}
func (this *WriteSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteSet)
	if !ok {
		that2, ok := that.(WriteSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.WriteSet) != len(that1.WriteSet) {
		return false
	}
	for i := range this.WriteSet {
		if !this.WriteSet[i].Equal(that1.WriteSet[i]) {
			return false
		}
	}
	return true
}
func (this *WriteOp) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WriteOp)
	if !ok {
		that2, ok := that.(WriteOp)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AccessPath.Equal(that1.AccessPath) {
		return false
	}
	if !bytes.Equal(this.Value, that1.Value) {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	return true
}
func (this *AccountState) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccountState)
	if !ok {
		that2, ok := that.(AccountState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Address, that1.Address) {
		return false
	}
	if !bytes.Equal(this.Blob, that1.Blob) {
		return false
	}
	return true
}
func (this *TransactionToCommit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TransactionToCommit)
	if !ok {
		that2, ok := that.(TransactionToCommit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SignedTxn.Equal(that1.SignedTxn) {
		return false
	}
	if len(this.AccountStates) != len(that1.AccountStates) {
		return false
	}
	for i := range this.AccountStates {
		if !this.AccountStates[i].Equal(that1.AccountStates[i]) {
			return false
		}
	}
	if len(this.Events) != len(that1.Events) {
		return false
	}
	for i := range this.Events {
		if !this.Events[i].Equal(that1.Events[i]) {
			return false
		}
	}
	if this.GasUsed != that1.GasUsed {
		return false
	}
	return true
}
func (this *TransactionListWithProof) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TransactionListWithProof)
	if !ok {
		that2, ok := that.(TransactionListWithProof)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Transactions) != len(that1.Transactions) {
		return false
	}
	for i := range this.Transactions {
		if !this.Transactions[i].Equal(that1.Transactions[i]) {
			return false
		}
	}
	if len(this.Infos) != len(that1.Infos) {
		return false
	}
	for i := range this.Infos {
		if !this.Infos[i].Equal(that1.Infos[i]) {
			return false
		}
	}
	if !this.EventsForVersions.Equal(that1.EventsForVersions) {
		return false
	}
	if !this.FirstTransactionVersion.Equal(that1.FirstTransactionVersion) {
		return false
	}
	if !this.ProofOfFirstTransaction.Equal(that1.ProofOfFirstTransaction) {
		return false
	}
	if !this.ProofOfLastTransaction.Equal(that1.ProofOfLastTransaction) {
		return false
	}
	return true
}
func (this *RawTransaction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&types.RawTransaction{")
	s = append(s, "SenderAccount: "+fmt.Sprintf("%#v", this.SenderAccount)+",\n")
	s = append(s, "SequenceNumber: "+fmt.Sprintf("%#v", this.SequenceNumber)+",\n")
	if this.Payload != nil {
		s = append(s, "Payload: "+fmt.Sprintf("%#v", this.Payload)+",\n")
	}
	s = append(s, "MaxGasAmount: "+fmt.Sprintf("%#v", this.MaxGasAmount)+",\n")
	s = append(s, "GasUnitPrice: "+fmt.Sprintf("%#v", this.GasUnitPrice)+",\n")
	s = append(s, "ExpirationTime: "+fmt.Sprintf("%#v", this.ExpirationTime)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RawTransaction_Program) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&types.RawTransaction_Program{` +
		`Program:` + fmt.Sprintf("%#v", this.Program) + `}`}, ", ")
	return s
}
func (this *RawTransaction_WriteSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&types.RawTransaction_WriteSet{` +
		`WriteSet:` + fmt.Sprintf("%#v", this.WriteSet) + `}`}, ", ")
	return s
}
func (this *Program) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.Program{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	if this.Arguments != nil {
		s = append(s, "Arguments: "+fmt.Sprintf("%#v", this.Arguments)+",\n")
	}
	s = append(s, "Modules: "+fmt.Sprintf("%#v", this.Modules)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TransactionArgument) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&types.TransactionArgument{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SignedTransaction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.SignedTransaction{")
	s = append(s, "RawTxnBytes: "+fmt.Sprintf("%#v", this.RawTxnBytes)+",\n")
	s = append(s, "SenderPublicKey: "+fmt.Sprintf("%#v", this.SenderPublicKey)+",\n")
	s = append(s, "SenderSignature: "+fmt.Sprintf("%#v", this.SenderSignature)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SignedTransactionWithProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&types.SignedTransactionWithProof{")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	if this.SignedTransaction != nil {
		s = append(s, "SignedTransaction: "+fmt.Sprintf("%#v", this.SignedTransaction)+",\n")
	}
	if this.Proof != nil {
		s = append(s, "Proof: "+fmt.Sprintf("%#v", this.Proof)+",\n")
	}
	if this.Events != nil {
		s = append(s, "Events: "+fmt.Sprintf("%#v", this.Events)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SignedTransactionsBlock) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.SignedTransactionsBlock{")
	if this.Transactions != nil {
		s = append(s, "Transactions: "+fmt.Sprintf("%#v", this.Transactions)+",\n")
	}
	s = append(s, "ValidatorPublicKey: "+fmt.Sprintf("%#v", this.ValidatorPublicKey)+",\n")
	s = append(s, "ValidatorSignature: "+fmt.Sprintf("%#v", this.ValidatorSignature)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteSet) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&types.WriteSet{")
	if this.WriteSet != nil {
		s = append(s, "WriteSet: "+fmt.Sprintf("%#v", this.WriteSet)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *WriteOp) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.WriteOp{")
	if this.AccessPath != nil {
		s = append(s, "AccessPath: "+fmt.Sprintf("%#v", this.AccessPath)+",\n")
	}
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AccountState) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&types.AccountState{")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "Blob: "+fmt.Sprintf("%#v", this.Blob)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TransactionToCommit) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&types.TransactionToCommit{")
	if this.SignedTxn != nil {
		s = append(s, "SignedTxn: "+fmt.Sprintf("%#v", this.SignedTxn)+",\n")
	}
	if this.AccountStates != nil {
		s = append(s, "AccountStates: "+fmt.Sprintf("%#v", this.AccountStates)+",\n")
	}
	if this.Events != nil {
		s = append(s, "Events: "+fmt.Sprintf("%#v", this.Events)+",\n")
	}
	s = append(s, "GasUsed: "+fmt.Sprintf("%#v", this.GasUsed)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TransactionListWithProof) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&types.TransactionListWithProof{")
	if this.Transactions != nil {
		s = append(s, "Transactions: "+fmt.Sprintf("%#v", this.Transactions)+",\n")
	}
	if this.Infos != nil {
		s = append(s, "Infos: "+fmt.Sprintf("%#v", this.Infos)+",\n")
	}
	if this.EventsForVersions != nil {
		s = append(s, "EventsForVersions: "+fmt.Sprintf("%#v", this.EventsForVersions)+",\n")
	}
	if this.FirstTransactionVersion != nil {
		s = append(s, "FirstTransactionVersion: "+fmt.Sprintf("%#v", this.FirstTransactionVersion)+",\n")
	}
	if this.ProofOfFirstTransaction != nil {
		s = append(s, "ProofOfFirstTransaction: "+fmt.Sprintf("%#v", this.ProofOfFirstTransaction)+",\n")
	}
	if this.ProofOfLastTransaction != nil {
		s = append(s, "ProofOfLastTransaction: "+fmt.Sprintf("%#v", this.ProofOfLastTransaction)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringTransaction(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *RawTransaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawTransaction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SenderAccount) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.SenderAccount)))
		i += copy(dAtA[i:], m.SenderAccount)
	}
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(m.SequenceNumber))
	}
	if m.Payload != nil {
		nn1, err1 := m.Payload.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += nn1
	}
	if m.MaxGasAmount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(m.MaxGasAmount))
	}
	if m.GasUnitPrice != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(m.GasUnitPrice))
	}
	if m.ExpirationTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(m.ExpirationTime))
	}
	return i, nil
}

func (m *RawTransaction_Program) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Program != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(m.Program.Size()))
		n2, err2 := m.Program.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	return i, nil
}
func (m *RawTransaction_WriteSet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.WriteSet != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(m.WriteSet.Size()))
		n3, err3 := m.WriteSet.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	return i, nil
}
func (m *Program) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Program) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Code) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	if len(m.Arguments) > 0 {
		for _, msg := range m.Arguments {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTransaction(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Modules) > 0 {
		for _, b := range m.Modules {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTransaction(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *TransactionArgument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionArgument) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(m.Type))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *SignedTransaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedTransaction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RawTxnBytes) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.RawTxnBytes)))
		i += copy(dAtA[i:], m.RawTxnBytes)
	}
	if len(m.SenderPublicKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.SenderPublicKey)))
		i += copy(dAtA[i:], m.SenderPublicKey)
	}
	if len(m.SenderSignature) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.SenderSignature)))
		i += copy(dAtA[i:], m.SenderSignature)
	}
	return i, nil
}

func (m *SignedTransactionWithProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedTransactionWithProof) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(m.Version))
	}
	if m.SignedTransaction != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(m.SignedTransaction.Size()))
		n4, err4 := m.SignedTransaction.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	if m.Proof != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(m.Proof.Size()))
		n5, err5 := m.Proof.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	if m.Events != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(m.Events.Size()))
		n6, err6 := m.Events.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	return i, nil
}

func (m *SignedTransactionsBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedTransactionsBlock) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Transactions) > 0 {
		for _, msg := range m.Transactions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTransaction(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ValidatorPublicKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.ValidatorPublicKey)))
		i += copy(dAtA[i:], m.ValidatorPublicKey)
	}
	if len(m.ValidatorSignature) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.ValidatorSignature)))
		i += copy(dAtA[i:], m.ValidatorSignature)
	}
	return i, nil
}

func (m *WriteSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.WriteSet) > 0 {
		for _, msg := range m.WriteSet {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTransaction(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *WriteOp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteOp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AccessPath != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(m.AccessPath.Size()))
		n7, err7 := m.AccessPath.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += n7
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *AccountState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.Blob) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Blob)))
		i += copy(dAtA[i:], m.Blob)
	}
	return i, nil
}

func (m *TransactionToCommit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionToCommit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SignedTxn != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(m.SignedTxn.Size()))
		n8, err8 := m.SignedTxn.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	if len(m.AccountStates) > 0 {
		for _, msg := range m.AccountStates {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTransaction(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTransaction(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.GasUsed != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(m.GasUsed))
	}
	return i, nil
}

func (m *TransactionListWithProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionListWithProof) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Transactions) > 0 {
		for _, msg := range m.Transactions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTransaction(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Infos) > 0 {
		for _, msg := range m.Infos {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTransaction(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.EventsForVersions != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(m.EventsForVersions.Size()))
		n9, err9 := m.EventsForVersions.MarshalTo(dAtA[i:])
		if err9 != nil {
			return 0, err9
		}
		i += n9
	}
	if m.FirstTransactionVersion != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(m.FirstTransactionVersion.Size()))
		n10, err10 := m.FirstTransactionVersion.MarshalTo(dAtA[i:])
		if err10 != nil {
			return 0, err10
		}
		i += n10
	}
	if m.ProofOfFirstTransaction != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(m.ProofOfFirstTransaction.Size()))
		n11, err11 := m.ProofOfFirstTransaction.MarshalTo(dAtA[i:])
		if err11 != nil {
			return 0, err11
		}
		i += n11
	}
	if m.ProofOfLastTransaction != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTransaction(dAtA, i, uint64(m.ProofOfLastTransaction.Size()))
		n12, err12 := m.ProofOfLastTransaction.MarshalTo(dAtA[i:])
		if err12 != nil {
			return 0, err12
		}
		i += n12
	}
	return i, nil
}

func encodeVarintTransaction(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RawTransaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SenderAccount)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovTransaction(uint64(m.SequenceNumber))
	}
	if m.Payload != nil {
		n += m.Payload.Size()
	}
	if m.MaxGasAmount != 0 {
		n += 1 + sovTransaction(uint64(m.MaxGasAmount))
	}
	if m.GasUnitPrice != 0 {
		n += 1 + sovTransaction(uint64(m.GasUnitPrice))
	}
	if m.ExpirationTime != 0 {
		n += 1 + sovTransaction(uint64(m.ExpirationTime))
	}
	return n
}

func (m *RawTransaction_Program) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Program != nil {
		l = m.Program.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *RawTransaction_WriteSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WriteSet != nil {
		l = m.WriteSet.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Program) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if len(m.Arguments) > 0 {
		for _, e := range m.Arguments {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if len(m.Modules) > 0 {
		for _, b := range m.Modules {
			l = len(b)
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	return n
}

func (m *TransactionArgument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTransaction(uint64(m.Type))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *SignedTransaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RawTxnBytes)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.SenderPublicKey)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.SenderSignature)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *SignedTransactionWithProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovTransaction(uint64(m.Version))
	}
	if m.SignedTransaction != nil {
		l = m.SignedTransaction.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Proof != nil {
		l = m.Proof.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Events != nil {
		l = m.Events.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *SignedTransactionsBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	l = len(m.ValidatorPublicKey)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.ValidatorSignature)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *WriteSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.WriteSet) > 0 {
		for _, e := range m.WriteSet {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	return n
}

func (m *WriteOp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccessPath != nil {
		l = m.AccessPath.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTransaction(uint64(m.Type))
	}
	return n
}

func (m *AccountState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Blob)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *TransactionToCommit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignedTxn != nil {
		l = m.SignedTxn.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if len(m.AccountStates) > 0 {
		for _, e := range m.AccountStates {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if m.GasUsed != 0 {
		n += 1 + sovTransaction(uint64(m.GasUsed))
	}
	return n
}

func (m *TransactionListWithProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Transactions) > 0 {
		for _, e := range m.Transactions {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if len(m.Infos) > 0 {
		for _, e := range m.Infos {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if m.EventsForVersions != nil {
		l = m.EventsForVersions.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.FirstTransactionVersion != nil {
		l = m.FirstTransactionVersion.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.ProofOfFirstTransaction != nil {
		l = m.ProofOfFirstTransaction.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.ProofOfLastTransaction != nil {
		l = m.ProofOfLastTransaction.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func sovTransaction(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTransaction(x uint64) (n int) {
	return sovTransaction(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *RawTransaction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RawTransaction{`,
		`SenderAccount:` + fmt.Sprintf("%v", this.SenderAccount) + `,`,
		`SequenceNumber:` + fmt.Sprintf("%v", this.SequenceNumber) + `,`,
		`Payload:` + fmt.Sprintf("%v", this.Payload) + `,`,
		`MaxGasAmount:` + fmt.Sprintf("%v", this.MaxGasAmount) + `,`,
		`GasUnitPrice:` + fmt.Sprintf("%v", this.GasUnitPrice) + `,`,
		`ExpirationTime:` + fmt.Sprintf("%v", this.ExpirationTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RawTransaction_Program) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RawTransaction_Program{`,
		`Program:` + strings.Replace(fmt.Sprintf("%v", this.Program), "Program", "Program", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RawTransaction_WriteSet) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RawTransaction_WriteSet{`,
		`WriteSet:` + strings.Replace(fmt.Sprintf("%v", this.WriteSet), "WriteSet", "WriteSet", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Program) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForArguments := "[]*TransactionArgument{"
	for _, f := range this.Arguments {
		repeatedStringForArguments += strings.Replace(f.String(), "TransactionArgument", "TransactionArgument", 1) + ","
	}
	repeatedStringForArguments += "}"
	s := strings.Join([]string{`&Program{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Arguments:` + repeatedStringForArguments + `,`,
		`Modules:` + fmt.Sprintf("%v", this.Modules) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TransactionArgument) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TransactionArgument{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignedTransaction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SignedTransaction{`,
		`RawTxnBytes:` + fmt.Sprintf("%v", this.RawTxnBytes) + `,`,
		`SenderPublicKey:` + fmt.Sprintf("%v", this.SenderPublicKey) + `,`,
		`SenderSignature:` + fmt.Sprintf("%v", this.SenderSignature) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignedTransactionWithProof) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SignedTransactionWithProof{`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`SignedTransaction:` + strings.Replace(this.SignedTransaction.String(), "SignedTransaction", "SignedTransaction", 1) + `,`,
		`Proof:` + strings.Replace(fmt.Sprintf("%v", this.Proof), "SignedTransactionProof", "SignedTransactionProof", 1) + `,`,
		`Events:` + strings.Replace(fmt.Sprintf("%v", this.Events), "EventsList", "EventsList", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignedTransactionsBlock) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTransactions := "[]*SignedTransaction{"
	for _, f := range this.Transactions {
		repeatedStringForTransactions += strings.Replace(f.String(), "SignedTransaction", "SignedTransaction", 1) + ","
	}
	repeatedStringForTransactions += "}"
	s := strings.Join([]string{`&SignedTransactionsBlock{`,
		`Transactions:` + repeatedStringForTransactions + `,`,
		`ValidatorPublicKey:` + fmt.Sprintf("%v", this.ValidatorPublicKey) + `,`,
		`ValidatorSignature:` + fmt.Sprintf("%v", this.ValidatorSignature) + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteSet) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForWriteSet := "[]*WriteOp{"
	for _, f := range this.WriteSet {
		repeatedStringForWriteSet += strings.Replace(f.String(), "WriteOp", "WriteOp", 1) + ","
	}
	repeatedStringForWriteSet += "}"
	s := strings.Join([]string{`&WriteSet{`,
		`WriteSet:` + repeatedStringForWriteSet + `,`,
		`}`,
	}, "")
	return s
}
func (this *WriteOp) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&WriteOp{`,
		`AccessPath:` + strings.Replace(fmt.Sprintf("%v", this.AccessPath), "AccessPath", "AccessPath", 1) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AccountState) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AccountState{`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`Blob:` + fmt.Sprintf("%v", this.Blob) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TransactionToCommit) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAccountStates := "[]*AccountState{"
	for _, f := range this.AccountStates {
		repeatedStringForAccountStates += strings.Replace(f.String(), "AccountState", "AccountState", 1) + ","
	}
	repeatedStringForAccountStates += "}"
	repeatedStringForEvents := "[]*Event{"
	for _, f := range this.Events {
		repeatedStringForEvents += strings.Replace(fmt.Sprintf("%v", f), "Event", "Event", 1) + ","
	}
	repeatedStringForEvents += "}"
	s := strings.Join([]string{`&TransactionToCommit{`,
		`SignedTxn:` + strings.Replace(this.SignedTxn.String(), "SignedTransaction", "SignedTransaction", 1) + `,`,
		`AccountStates:` + repeatedStringForAccountStates + `,`,
		`Events:` + repeatedStringForEvents + `,`,
		`GasUsed:` + fmt.Sprintf("%v", this.GasUsed) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TransactionListWithProof) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForTransactions := "[]*SignedTransaction{"
	for _, f := range this.Transactions {
		repeatedStringForTransactions += strings.Replace(f.String(), "SignedTransaction", "SignedTransaction", 1) + ","
	}
	repeatedStringForTransactions += "}"
	repeatedStringForInfos := "[]*TransactionInfo{"
	for _, f := range this.Infos {
		repeatedStringForInfos += strings.Replace(fmt.Sprintf("%v", f), "TransactionInfo", "TransactionInfo", 1) + ","
	}
	repeatedStringForInfos += "}"
	s := strings.Join([]string{`&TransactionListWithProof{`,
		`Transactions:` + repeatedStringForTransactions + `,`,
		`Infos:` + repeatedStringForInfos + `,`,
		`EventsForVersions:` + strings.Replace(fmt.Sprintf("%v", this.EventsForVersions), "EventsForVersions", "EventsForVersions", 1) + `,`,
		`FirstTransactionVersion:` + strings.Replace(fmt.Sprintf("%v", this.FirstTransactionVersion), "UInt64Value", "types.UInt64Value", 1) + `,`,
		`ProofOfFirstTransaction:` + strings.Replace(fmt.Sprintf("%v", this.ProofOfFirstTransaction), "AccumulatorProof", "AccumulatorProof", 1) + `,`,
		`ProofOfLastTransaction:` + strings.Replace(fmt.Sprintf("%v", this.ProofOfLastTransaction), "AccumulatorProof", "AccumulatorProof", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringTransaction(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *RawTransaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawTransaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawTransaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderAccount", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderAccount = append(m.SenderAccount[:0], dAtA[iNdEx:postIndex]...)
			if m.SenderAccount == nil {
				m.SenderAccount = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Program", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Program{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &RawTransaction_Program{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WriteSet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &RawTransaction_WriteSet{v}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxGasAmount", wireType)
			}
			m.MaxGasAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxGasAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUnitPrice", wireType)
			}
			m.GasUnitPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasUnitPrice |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationTime", wireType)
			}
			m.ExpirationTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Program) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Program: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Program: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = append(m.Code[:0], dAtA[iNdEx:postIndex]...)
			if m.Code == nil {
				m.Code = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arguments = append(m.Arguments, &TransactionArgument{})
			if err := m.Arguments[len(m.Arguments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modules", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Modules = append(m.Modules, make([]byte, postIndex-iNdEx))
			copy(m.Modules[len(m.Modules)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionArgument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionArgument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionArgument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TransactionArgument_ArgType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedTransaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedTransaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedTransaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawTxnBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawTxnBytes = append(m.RawTxnBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.RawTxnBytes == nil {
				m.RawTxnBytes = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderPublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderPublicKey = append(m.SenderPublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SenderPublicKey == nil {
				m.SenderPublicKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderSignature = append(m.SenderSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.SenderSignature == nil {
				m.SenderSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedTransactionWithProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedTransactionWithProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedTransactionWithProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignedTransaction == nil {
				m.SignedTransaction = &SignedTransaction{}
			}
			if err := m.SignedTransaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = &SignedTransactionProof{}
			}
			if err := m.Proof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Events == nil {
				m.Events = &EventsList{}
			}
			if err := m.Events.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedTransactionsBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedTransactionsBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedTransactionsBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, &SignedTransaction{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorPublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorPublicKey = append(m.ValidatorPublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.ValidatorPublicKey == nil {
				m.ValidatorPublicKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorSignature = append(m.ValidatorSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.ValidatorSignature == nil {
				m.ValidatorSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WriteSet = append(m.WriteSet, &WriteOp{})
			if err := m.WriteSet[len(m.WriteSet)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteOp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessPath", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessPath == nil {
				m.AccessPath = &AccessPath{}
			}
			if err := m.AccessPath.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= WriteOpType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blob", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blob = append(m.Blob[:0], dAtA[iNdEx:postIndex]...)
			if m.Blob == nil {
				m.Blob = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionToCommit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionToCommit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionToCommit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignedTxn == nil {
				m.SignedTxn = &SignedTransaction{}
			}
			if err := m.SignedTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountStates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountStates = append(m.AccountStates, &AccountState{})
			if err := m.AccountStates[len(m.AccountStates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
			}
			m.GasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionListWithProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionListWithProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionListWithProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactions = append(m.Transactions, &SignedTransaction{})
			if err := m.Transactions[len(m.Transactions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Infos = append(m.Infos, &TransactionInfo{})
			if err := m.Infos[len(m.Infos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventsForVersions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EventsForVersions == nil {
				m.EventsForVersions = &EventsForVersions{}
			}
			if err := m.EventsForVersions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstTransactionVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FirstTransactionVersion == nil {
				m.FirstTransactionVersion = &types.UInt64Value{}
			}
			if err := m.FirstTransactionVersion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofOfFirstTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofOfFirstTransaction == nil {
				m.ProofOfFirstTransaction = &AccumulatorProof{}
			}
			if err := m.ProofOfFirstTransaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofOfLastTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofOfLastTransaction == nil {
				m.ProofOfLastTransaction = &AccumulatorProof{}
			}
			if err := m.ProofOfLastTransaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTransaction(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTransaction
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthTransaction
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTransaction
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTransaction(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthTransaction
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTransaction = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTransaction   = fmt.Errorf("proto: integer overflow")
)
