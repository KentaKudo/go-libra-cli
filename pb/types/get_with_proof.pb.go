// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: get_with_proof.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// This API is used to update the client to the latest ledger version and
// optionally also request 1..n other pieces of data.  This allows for batch
// queries.  All queries return proofs that a client should check to validate
// the data.
//
// Note that if a client only wishes to update to the latest LedgerInfo and
// receive the proof that this latest ledger extends the client_known_version
// ledger the client had, they can simply set the requested_items to an empty
// list.
type UpdateToLatestLedgerRequest struct {
	// This is the version the client already trusts. Usually the client should
	// set this to the version it obtained the last time it synced with the
	// chain. If this is the first time ever the client sends a request, it must
	// use the waypoint hard-coded in its software.
	ClientKnownVersion uint64 `protobuf:"varint,1,opt,name=client_known_version,json=clientKnownVersion,proto3" json:"client_known_version,omitempty"`
	// The items for which we are requesting data in this API call.
	RequestedItems []*RequestItem `protobuf:"bytes,2,rep,name=requested_items,json=requestedItems,proto3" json:"requested_items,omitempty"`
}

func (m *UpdateToLatestLedgerRequest) Reset()      { *m = UpdateToLatestLedgerRequest{} }
func (*UpdateToLatestLedgerRequest) ProtoMessage() {}
func (*UpdateToLatestLedgerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ffcd28ab9b25870, []int{0}
}
func (m *UpdateToLatestLedgerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateToLatestLedgerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateToLatestLedgerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateToLatestLedgerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateToLatestLedgerRequest.Merge(m, src)
}
func (m *UpdateToLatestLedgerRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateToLatestLedgerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateToLatestLedgerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateToLatestLedgerRequest proto.InternalMessageInfo

func (m *UpdateToLatestLedgerRequest) GetClientKnownVersion() uint64 {
	if m != nil {
		return m.ClientKnownVersion
	}
	return 0
}

func (m *UpdateToLatestLedgerRequest) GetRequestedItems() []*RequestItem {
	if m != nil {
		return m.RequestedItems
	}
	return nil
}

type RequestItem struct {
	// Types that are valid to be assigned to RequestedItems:
	//	*RequestItem_GetAccountStateRequest
	//	*RequestItem_GetAccountTransactionBySequenceNumberRequest
	//	*RequestItem_GetEventsByEventAccessPathRequest
	//	*RequestItem_GetTransactionsRequest
	RequestedItems isRequestItem_RequestedItems `protobuf_oneof:"requested_items"`
}

func (m *RequestItem) Reset()      { *m = RequestItem{} }
func (*RequestItem) ProtoMessage() {}
func (*RequestItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ffcd28ab9b25870, []int{1}
}
func (m *RequestItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestItem.Merge(m, src)
}
func (m *RequestItem) XXX_Size() int {
	return m.Size()
}
func (m *RequestItem) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestItem.DiscardUnknown(m)
}

var xxx_messageInfo_RequestItem proto.InternalMessageInfo

type isRequestItem_RequestedItems interface {
	isRequestItem_RequestedItems()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type RequestItem_GetAccountStateRequest struct {
	GetAccountStateRequest *GetAccountStateRequest `protobuf:"bytes,1,opt,name=get_account_state_request,json=getAccountStateRequest,proto3,oneof"`
}
type RequestItem_GetAccountTransactionBySequenceNumberRequest struct {
	GetAccountTransactionBySequenceNumberRequest *GetAccountTransactionBySequenceNumberRequest `protobuf:"bytes,2,opt,name=get_account_transaction_by_sequence_number_request,json=getAccountTransactionBySequenceNumberRequest,proto3,oneof"`
}
type RequestItem_GetEventsByEventAccessPathRequest struct {
	GetEventsByEventAccessPathRequest *GetEventsByEventAccessPathRequest `protobuf:"bytes,3,opt,name=get_events_by_event_access_path_request,json=getEventsByEventAccessPathRequest,proto3,oneof"`
}
type RequestItem_GetTransactionsRequest struct {
	GetTransactionsRequest *GetTransactionsRequest `protobuf:"bytes,4,opt,name=get_transactions_request,json=getTransactionsRequest,proto3,oneof"`
}

func (*RequestItem_GetAccountStateRequest) isRequestItem_RequestedItems()                       {}
func (*RequestItem_GetAccountTransactionBySequenceNumberRequest) isRequestItem_RequestedItems() {}
func (*RequestItem_GetEventsByEventAccessPathRequest) isRequestItem_RequestedItems()            {}
func (*RequestItem_GetTransactionsRequest) isRequestItem_RequestedItems()                       {}

func (m *RequestItem) GetRequestedItems() isRequestItem_RequestedItems {
	if m != nil {
		return m.RequestedItems
	}
	return nil
}

func (m *RequestItem) GetGetAccountStateRequest() *GetAccountStateRequest {
	if x, ok := m.GetRequestedItems().(*RequestItem_GetAccountStateRequest); ok {
		return x.GetAccountStateRequest
	}
	return nil
}

func (m *RequestItem) GetGetAccountTransactionBySequenceNumberRequest() *GetAccountTransactionBySequenceNumberRequest {
	if x, ok := m.GetRequestedItems().(*RequestItem_GetAccountTransactionBySequenceNumberRequest); ok {
		return x.GetAccountTransactionBySequenceNumberRequest
	}
	return nil
}

func (m *RequestItem) GetGetEventsByEventAccessPathRequest() *GetEventsByEventAccessPathRequest {
	if x, ok := m.GetRequestedItems().(*RequestItem_GetEventsByEventAccessPathRequest); ok {
		return x.GetEventsByEventAccessPathRequest
	}
	return nil
}

func (m *RequestItem) GetGetTransactionsRequest() *GetTransactionsRequest {
	if x, ok := m.GetRequestedItems().(*RequestItem_GetTransactionsRequest); ok {
		return x.GetTransactionsRequest
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RequestItem) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RequestItem_OneofMarshaler, _RequestItem_OneofUnmarshaler, _RequestItem_OneofSizer, []interface{}{
		(*RequestItem_GetAccountStateRequest)(nil),
		(*RequestItem_GetAccountTransactionBySequenceNumberRequest)(nil),
		(*RequestItem_GetEventsByEventAccessPathRequest)(nil),
		(*RequestItem_GetTransactionsRequest)(nil),
	}
}

func _RequestItem_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RequestItem)
	// requested_items
	switch x := m.RequestedItems.(type) {
	case *RequestItem_GetAccountStateRequest:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GetAccountStateRequest); err != nil {
			return err
		}
	case *RequestItem_GetAccountTransactionBySequenceNumberRequest:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GetAccountTransactionBySequenceNumberRequest); err != nil {
			return err
		}
	case *RequestItem_GetEventsByEventAccessPathRequest:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GetEventsByEventAccessPathRequest); err != nil {
			return err
		}
	case *RequestItem_GetTransactionsRequest:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GetTransactionsRequest); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RequestItem.RequestedItems has unexpected type %T", x)
	}
	return nil
}

func _RequestItem_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RequestItem)
	switch tag {
	case 1: // requested_items.get_account_state_request
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GetAccountStateRequest)
		err := b.DecodeMessage(msg)
		m.RequestedItems = &RequestItem_GetAccountStateRequest{msg}
		return true, err
	case 2: // requested_items.get_account_transaction_by_sequence_number_request
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GetAccountTransactionBySequenceNumberRequest)
		err := b.DecodeMessage(msg)
		m.RequestedItems = &RequestItem_GetAccountTransactionBySequenceNumberRequest{msg}
		return true, err
	case 3: // requested_items.get_events_by_event_access_path_request
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GetEventsByEventAccessPathRequest)
		err := b.DecodeMessage(msg)
		m.RequestedItems = &RequestItem_GetEventsByEventAccessPathRequest{msg}
		return true, err
	case 4: // requested_items.get_transactions_request
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GetTransactionsRequest)
		err := b.DecodeMessage(msg)
		m.RequestedItems = &RequestItem_GetTransactionsRequest{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RequestItem_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RequestItem)
	// requested_items
	switch x := m.RequestedItems.(type) {
	case *RequestItem_GetAccountStateRequest:
		s := proto.Size(x.GetAccountStateRequest)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestItem_GetAccountTransactionBySequenceNumberRequest:
		s := proto.Size(x.GetAccountTransactionBySequenceNumberRequest)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestItem_GetEventsByEventAccessPathRequest:
		s := proto.Size(x.GetEventsByEventAccessPathRequest)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestItem_GetTransactionsRequest:
		s := proto.Size(x.GetTransactionsRequest)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Response from getting latest ledger
type UpdateToLatestLedgerResponse struct {
	// Responses to the queries posed by the requests. The proofs generated will
	// be relative to the version of the latest ledger provided below.
	ResponseItems []*ResponseItem `protobuf:"bytes,1,rep,name=response_items,json=responseItems,proto3" json:"response_items,omitempty"`
	// The latest ledger info this node has. It will come with at least 2f+1
	// validator signatures as well as a proof that shows the latest ledger
	// extends the old ledger the client had.
	LedgerInfoWithSigs *LedgerInfoWithSignatures `protobuf:"bytes,2,opt,name=ledger_info_with_sigs,json=ledgerInfoWithSigs,proto3" json:"ledger_info_with_sigs,omitempty"`
	// Validator change events from what the client last knew.  This is used to
	// inform the client of validator changes from the client's last known version
	// until the current version
	ValidatorChangeEvents []*ValidatorChangeEventWithProof `protobuf:"bytes,3,rep,name=validator_change_events,json=validatorChangeEvents,proto3" json:"validator_change_events,omitempty"`
}

func (m *UpdateToLatestLedgerResponse) Reset()      { *m = UpdateToLatestLedgerResponse{} }
func (*UpdateToLatestLedgerResponse) ProtoMessage() {}
func (*UpdateToLatestLedgerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ffcd28ab9b25870, []int{2}
}
func (m *UpdateToLatestLedgerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateToLatestLedgerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateToLatestLedgerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateToLatestLedgerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateToLatestLedgerResponse.Merge(m, src)
}
func (m *UpdateToLatestLedgerResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateToLatestLedgerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateToLatestLedgerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateToLatestLedgerResponse proto.InternalMessageInfo

func (m *UpdateToLatestLedgerResponse) GetResponseItems() []*ResponseItem {
	if m != nil {
		return m.ResponseItems
	}
	return nil
}

func (m *UpdateToLatestLedgerResponse) GetLedgerInfoWithSigs() *LedgerInfoWithSignatures {
	if m != nil {
		return m.LedgerInfoWithSigs
	}
	return nil
}

func (m *UpdateToLatestLedgerResponse) GetValidatorChangeEvents() []*ValidatorChangeEventWithProof {
	if m != nil {
		return m.ValidatorChangeEvents
	}
	return nil
}

// Individual response items to the queries posed by the requests
type ResponseItem struct {
	// Types that are valid to be assigned to ResponseItems:
	//	*ResponseItem_GetAccountStateResponse
	//	*ResponseItem_GetAccountTransactionBySequenceNumberResponse
	//	*ResponseItem_GetEventsByEventAccessPathResponse
	//	*ResponseItem_GetTransactionsResponse
	ResponseItems isResponseItem_ResponseItems `protobuf_oneof:"response_items"`
}

func (m *ResponseItem) Reset()      { *m = ResponseItem{} }
func (*ResponseItem) ProtoMessage() {}
func (*ResponseItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ffcd28ab9b25870, []int{3}
}
func (m *ResponseItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseItem.Merge(m, src)
}
func (m *ResponseItem) XXX_Size() int {
	return m.Size()
}
func (m *ResponseItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseItem.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseItem proto.InternalMessageInfo

type isResponseItem_ResponseItems interface {
	isResponseItem_ResponseItems()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ResponseItem_GetAccountStateResponse struct {
	GetAccountStateResponse *GetAccountStateResponse `protobuf:"bytes,3,opt,name=get_account_state_response,json=getAccountStateResponse,proto3,oneof"`
}
type ResponseItem_GetAccountTransactionBySequenceNumberResponse struct {
	GetAccountTransactionBySequenceNumberResponse *GetAccountTransactionBySequenceNumberResponse `protobuf:"bytes,4,opt,name=get_account_transaction_by_sequence_number_response,json=getAccountTransactionBySequenceNumberResponse,proto3,oneof"`
}
type ResponseItem_GetEventsByEventAccessPathResponse struct {
	GetEventsByEventAccessPathResponse *GetEventsByEventAccessPathResponse `protobuf:"bytes,5,opt,name=get_events_by_event_access_path_response,json=getEventsByEventAccessPathResponse,proto3,oneof"`
}
type ResponseItem_GetTransactionsResponse struct {
	GetTransactionsResponse *GetTransactionsResponse `protobuf:"bytes,6,opt,name=get_transactions_response,json=getTransactionsResponse,proto3,oneof"`
}

func (*ResponseItem_GetAccountStateResponse) isResponseItem_ResponseItems()                       {}
func (*ResponseItem_GetAccountTransactionBySequenceNumberResponse) isResponseItem_ResponseItems() {}
func (*ResponseItem_GetEventsByEventAccessPathResponse) isResponseItem_ResponseItems()            {}
func (*ResponseItem_GetTransactionsResponse) isResponseItem_ResponseItems()                       {}

func (m *ResponseItem) GetResponseItems() isResponseItem_ResponseItems {
	if m != nil {
		return m.ResponseItems
	}
	return nil
}

func (m *ResponseItem) GetGetAccountStateResponse() *GetAccountStateResponse {
	if x, ok := m.GetResponseItems().(*ResponseItem_GetAccountStateResponse); ok {
		return x.GetAccountStateResponse
	}
	return nil
}

func (m *ResponseItem) GetGetAccountTransactionBySequenceNumberResponse() *GetAccountTransactionBySequenceNumberResponse {
	if x, ok := m.GetResponseItems().(*ResponseItem_GetAccountTransactionBySequenceNumberResponse); ok {
		return x.GetAccountTransactionBySequenceNumberResponse
	}
	return nil
}

func (m *ResponseItem) GetGetEventsByEventAccessPathResponse() *GetEventsByEventAccessPathResponse {
	if x, ok := m.GetResponseItems().(*ResponseItem_GetEventsByEventAccessPathResponse); ok {
		return x.GetEventsByEventAccessPathResponse
	}
	return nil
}

func (m *ResponseItem) GetGetTransactionsResponse() *GetTransactionsResponse {
	if x, ok := m.GetResponseItems().(*ResponseItem_GetTransactionsResponse); ok {
		return x.GetTransactionsResponse
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ResponseItem) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ResponseItem_OneofMarshaler, _ResponseItem_OneofUnmarshaler, _ResponseItem_OneofSizer, []interface{}{
		(*ResponseItem_GetAccountStateResponse)(nil),
		(*ResponseItem_GetAccountTransactionBySequenceNumberResponse)(nil),
		(*ResponseItem_GetEventsByEventAccessPathResponse)(nil),
		(*ResponseItem_GetTransactionsResponse)(nil),
	}
}

func _ResponseItem_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ResponseItem)
	// response_items
	switch x := m.ResponseItems.(type) {
	case *ResponseItem_GetAccountStateResponse:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GetAccountStateResponse); err != nil {
			return err
		}
	case *ResponseItem_GetAccountTransactionBySequenceNumberResponse:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GetAccountTransactionBySequenceNumberResponse); err != nil {
			return err
		}
	case *ResponseItem_GetEventsByEventAccessPathResponse:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GetEventsByEventAccessPathResponse); err != nil {
			return err
		}
	case *ResponseItem_GetTransactionsResponse:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GetTransactionsResponse); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ResponseItem.ResponseItems has unexpected type %T", x)
	}
	return nil
}

func _ResponseItem_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ResponseItem)
	switch tag {
	case 3: // response_items.get_account_state_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GetAccountStateResponse)
		err := b.DecodeMessage(msg)
		m.ResponseItems = &ResponseItem_GetAccountStateResponse{msg}
		return true, err
	case 4: // response_items.get_account_transaction_by_sequence_number_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GetAccountTransactionBySequenceNumberResponse)
		err := b.DecodeMessage(msg)
		m.ResponseItems = &ResponseItem_GetAccountTransactionBySequenceNumberResponse{msg}
		return true, err
	case 5: // response_items.get_events_by_event_access_path_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GetEventsByEventAccessPathResponse)
		err := b.DecodeMessage(msg)
		m.ResponseItems = &ResponseItem_GetEventsByEventAccessPathResponse{msg}
		return true, err
	case 6: // response_items.get_transactions_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GetTransactionsResponse)
		err := b.DecodeMessage(msg)
		m.ResponseItems = &ResponseItem_GetTransactionsResponse{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ResponseItem_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ResponseItem)
	// response_items
	switch x := m.ResponseItems.(type) {
	case *ResponseItem_GetAccountStateResponse:
		s := proto.Size(x.GetAccountStateResponse)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseItem_GetAccountTransactionBySequenceNumberResponse:
		s := proto.Size(x.GetAccountTransactionBySequenceNumberResponse)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseItem_GetEventsByEventAccessPathResponse:
		s := proto.Size(x.GetEventsByEventAccessPathResponse)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseItem_GetTransactionsResponse:
		s := proto.Size(x.GetTransactionsResponse)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Gets latest state for an account.
type GetAccountStateRequest struct {
	// Account for which we are fetching the state.
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *GetAccountStateRequest) Reset()      { *m = GetAccountStateRequest{} }
func (*GetAccountStateRequest) ProtoMessage() {}
func (*GetAccountStateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ffcd28ab9b25870, []int{4}
}
func (m *GetAccountStateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAccountStateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAccountStateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAccountStateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAccountStateRequest.Merge(m, src)
}
func (m *GetAccountStateRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAccountStateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAccountStateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAccountStateRequest proto.InternalMessageInfo

func (m *GetAccountStateRequest) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

// State information returned by a get account state query.
type GetAccountStateResponse struct {
	// Blob value representing the account state together with proof the client
	// can utilize to verify it.
	AccountStateWithProof *AccountStateWithProof `protobuf:"bytes,1,opt,name=account_state_with_proof,json=accountStateWithProof,proto3" json:"account_state_with_proof,omitempty"`
}

func (m *GetAccountStateResponse) Reset()      { *m = GetAccountStateResponse{} }
func (*GetAccountStateResponse) ProtoMessage() {}
func (*GetAccountStateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ffcd28ab9b25870, []int{5}
}
func (m *GetAccountStateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAccountStateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAccountStateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAccountStateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAccountStateResponse.Merge(m, src)
}
func (m *GetAccountStateResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetAccountStateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAccountStateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAccountStateResponse proto.InternalMessageInfo

func (m *GetAccountStateResponse) GetAccountStateWithProof() *AccountStateWithProof {
	if m != nil {
		return m.AccountStateWithProof
	}
	return nil
}

// -----------------------------------------------------------------------------
// ---------------- Get single transaction by account + sequence number
// -----------------------------------------------------------------------------
// Get transactions that altered an account - this includes both sent and
// received. A user of this should check that the data returned matches what
// they expect.  As an example, a potential attack vector would be something
// like the following: Alice is buying an apple from Bob. Alice's phone signs a
// transaction X with sequence number N that pays coins to Bob. Alice transmits
// this signature to Bob's payment terminal which then submits the transaction
// and checks its status to see if Alice can be given the apple. However, as Bob
// is doing this Alice constructs a second transaction X' also with sequence
// number N. Alice gets that transaction inserted in the blockchain. If Bob
// isn't thoughtful about how he uses this API he may assume that if he asks for
// the N'th transaction on Alice's account that when the API returns that this
// means the transaction has gone through. The point here is that one should be
// careful in reading too much into "transaction X is on the chain" and focus on
// the logs, which tell you what the transaction did.
//
// If a client submitted a transaction, they should also verify that the hash of
// the returned transaction matches what they submitted.  As an example, if a
// client has two wallets that share the same account, they may both submit a
// transaction at the same sequence number and only one will be committed.  A
// client should never assume that if they receive the response that this
// transaction was included that it means that this is definitely the
// transaction that was submitted.  They should check that the hash matches what
// they sent
type GetAccountTransactionBySequenceNumberRequest struct {
	// Account for which to query transactions
	Account        []byte `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	SequenceNumber uint64 `protobuf:"varint,2,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	// Set to true to fetch events for the transaction at this version
	FetchEvents bool `protobuf:"varint,3,opt,name=fetch_events,json=fetchEvents,proto3" json:"fetch_events,omitempty"`
}

func (m *GetAccountTransactionBySequenceNumberRequest) Reset() {
	*m = GetAccountTransactionBySequenceNumberRequest{}
}
func (*GetAccountTransactionBySequenceNumberRequest) ProtoMessage() {}
func (*GetAccountTransactionBySequenceNumberRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ffcd28ab9b25870, []int{6}
}
func (m *GetAccountTransactionBySequenceNumberRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAccountTransactionBySequenceNumberRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAccountTransactionBySequenceNumberRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAccountTransactionBySequenceNumberRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAccountTransactionBySequenceNumberRequest.Merge(m, src)
}
func (m *GetAccountTransactionBySequenceNumberRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAccountTransactionBySequenceNumberRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAccountTransactionBySequenceNumberRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAccountTransactionBySequenceNumberRequest proto.InternalMessageInfo

func (m *GetAccountTransactionBySequenceNumberRequest) GetAccount() []byte {
	if m != nil {
		return m.Account
	}
	return nil
}

func (m *GetAccountTransactionBySequenceNumberRequest) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func (m *GetAccountTransactionBySequenceNumberRequest) GetFetchEvents() bool {
	if m != nil {
		return m.FetchEvents
	}
	return false
}

// Transaction information for transactions requested by
// GetAccountTransactionsRequest
type GetAccountTransactionBySequenceNumberResponse struct {
	// When the transaction requested is committed, return the committed
	// transaction with proof.
	SignedTransactionWithProof *SignedTransactionWithProof `protobuf:"bytes,2,opt,name=signed_transaction_with_proof,json=signedTransactionWithProof,proto3" json:"signed_transaction_with_proof,omitempty"`
	// When the transaction requested is not committed, we give a proof that
	// shows the current sequence number is smaller than what would have been if
	// the transaction was committed.
	ProofOfCurrentSequenceNumber *AccountStateWithProof `protobuf:"bytes,3,opt,name=proof_of_current_sequence_number,json=proofOfCurrentSequenceNumber,proto3" json:"proof_of_current_sequence_number,omitempty"`
}

func (m *GetAccountTransactionBySequenceNumberResponse) Reset() {
	*m = GetAccountTransactionBySequenceNumberResponse{}
}
func (*GetAccountTransactionBySequenceNumberResponse) ProtoMessage() {}
func (*GetAccountTransactionBySequenceNumberResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ffcd28ab9b25870, []int{7}
}
func (m *GetAccountTransactionBySequenceNumberResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAccountTransactionBySequenceNumberResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAccountTransactionBySequenceNumberResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAccountTransactionBySequenceNumberResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAccountTransactionBySequenceNumberResponse.Merge(m, src)
}
func (m *GetAccountTransactionBySequenceNumberResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetAccountTransactionBySequenceNumberResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAccountTransactionBySequenceNumberResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAccountTransactionBySequenceNumberResponse proto.InternalMessageInfo

func (m *GetAccountTransactionBySequenceNumberResponse) GetSignedTransactionWithProof() *SignedTransactionWithProof {
	if m != nil {
		return m.SignedTransactionWithProof
	}
	return nil
}

func (m *GetAccountTransactionBySequenceNumberResponse) GetProofOfCurrentSequenceNumber() *AccountStateWithProof {
	if m != nil {
		return m.ProofOfCurrentSequenceNumber
	}
	return nil
}

// Get events that exist on an event access path.  In the current world,
// a user may specify events that were received, events that were sent, or any
// event that modifies their account
type GetEventsByEventAccessPathRequest struct {
	AccessPath *AccessPath `protobuf:"bytes,1,opt,name=access_path,json=accessPath,proto3" json:"access_path,omitempty"`
	// The sequence number of the event to start with for this query. Use a
	// sequence number of MAX_INT to represent the latest.
	StartEventSeqNum uint64 `protobuf:"varint,2,opt,name=start_event_seq_num,json=startEventSeqNum,proto3" json:"start_event_seq_num,omitempty"`
	// If ascending is true this query will return up to `limit` events that were
	// emitted after `start_event_seq_num`. Otherwise it will return up to `limit`
	// events before the offset. Both cases are inclusive.
	Ascending bool `protobuf:"varint,3,opt,name=ascending,proto3" json:"ascending,omitempty"`
	// Limit number of results
	Limit uint64 `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *GetEventsByEventAccessPathRequest) Reset()      { *m = GetEventsByEventAccessPathRequest{} }
func (*GetEventsByEventAccessPathRequest) ProtoMessage() {}
func (*GetEventsByEventAccessPathRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ffcd28ab9b25870, []int{8}
}
func (m *GetEventsByEventAccessPathRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetEventsByEventAccessPathRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetEventsByEventAccessPathRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetEventsByEventAccessPathRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetEventsByEventAccessPathRequest.Merge(m, src)
}
func (m *GetEventsByEventAccessPathRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetEventsByEventAccessPathRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetEventsByEventAccessPathRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetEventsByEventAccessPathRequest proto.InternalMessageInfo

func (m *GetEventsByEventAccessPathRequest) GetAccessPath() *AccessPath {
	if m != nil {
		return m.AccessPath
	}
	return nil
}

func (m *GetEventsByEventAccessPathRequest) GetStartEventSeqNum() uint64 {
	if m != nil {
		return m.StartEventSeqNum
	}
	return 0
}

func (m *GetEventsByEventAccessPathRequest) GetAscending() bool {
	if m != nil {
		return m.Ascending
	}
	return false
}

func (m *GetEventsByEventAccessPathRequest) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type GetEventsByEventAccessPathResponse struct {
	// Returns an event and proof of each of the events in the request. The first
	// element of proofs will be the closest to `start_event_seq_num`.
	EventsWithProof []*EventWithProof `protobuf:"bytes,1,rep,name=events_with_proof,json=eventsWithProof,proto3" json:"events_with_proof,omitempty"`
	// If the number of events returned is less than `limit` for an ascending
	// query or if start_event_seq_num > the latest seq_num for a descending
	// query,  returns the state of the account containing the given access path
	// in the latest state. This allows the client to verify that there are in
	// fact no extra events.
	//
	// The LedgerInfoWithSignatures which is on the main
	// UpdateToLatestLedgerResponse can be used to validate this.
	ProofOfLatestEvent *AccountStateWithProof `protobuf:"bytes,2,opt,name=proof_of_latest_event,json=proofOfLatestEvent,proto3" json:"proof_of_latest_event,omitempty"`
}

func (m *GetEventsByEventAccessPathResponse) Reset()      { *m = GetEventsByEventAccessPathResponse{} }
func (*GetEventsByEventAccessPathResponse) ProtoMessage() {}
func (*GetEventsByEventAccessPathResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ffcd28ab9b25870, []int{9}
}
func (m *GetEventsByEventAccessPathResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetEventsByEventAccessPathResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetEventsByEventAccessPathResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetEventsByEventAccessPathResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetEventsByEventAccessPathResponse.Merge(m, src)
}
func (m *GetEventsByEventAccessPathResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetEventsByEventAccessPathResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetEventsByEventAccessPathResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetEventsByEventAccessPathResponse proto.InternalMessageInfo

func (m *GetEventsByEventAccessPathResponse) GetEventsWithProof() []*EventWithProof {
	if m != nil {
		return m.EventsWithProof
	}
	return nil
}

func (m *GetEventsByEventAccessPathResponse) GetProofOfLatestEvent() *AccountStateWithProof {
	if m != nil {
		return m.ProofOfLatestEvent
	}
	return nil
}

// Get up to limit transactions starting from start_version.
type GetTransactionsRequest struct {
	// The version of the transaction to start with for this query.  Use a version
	// of MAX_INT to represent the latest.
	StartVersion uint64 `protobuf:"varint,1,opt,name=start_version,json=startVersion,proto3" json:"start_version,omitempty"`
	// Limit number of results
	Limit uint64 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	// Set to true to fetch events for the transaction at each version
	FetchEvents bool `protobuf:"varint,3,opt,name=fetch_events,json=fetchEvents,proto3" json:"fetch_events,omitempty"`
}

func (m *GetTransactionsRequest) Reset()      { *m = GetTransactionsRequest{} }
func (*GetTransactionsRequest) ProtoMessage() {}
func (*GetTransactionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ffcd28ab9b25870, []int{10}
}
func (m *GetTransactionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransactionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransactionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransactionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransactionsRequest.Merge(m, src)
}
func (m *GetTransactionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTransactionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransactionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransactionsRequest proto.InternalMessageInfo

func (m *GetTransactionsRequest) GetStartVersion() uint64 {
	if m != nil {
		return m.StartVersion
	}
	return 0
}

func (m *GetTransactionsRequest) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *GetTransactionsRequest) GetFetchEvents() bool {
	if m != nil {
		return m.FetchEvents
	}
	return false
}

type GetTransactionsResponse struct {
	TxnListWithProof *TransactionListWithProof `protobuf:"bytes,1,opt,name=txn_list_with_proof,json=txnListWithProof,proto3" json:"txn_list_with_proof,omitempty"`
}

func (m *GetTransactionsResponse) Reset()      { *m = GetTransactionsResponse{} }
func (*GetTransactionsResponse) ProtoMessage() {}
func (*GetTransactionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ffcd28ab9b25870, []int{11}
}
func (m *GetTransactionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransactionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransactionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransactionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransactionsResponse.Merge(m, src)
}
func (m *GetTransactionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTransactionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransactionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransactionsResponse proto.InternalMessageInfo

func (m *GetTransactionsResponse) GetTxnListWithProof() *TransactionListWithProof {
	if m != nil {
		return m.TxnListWithProof
	}
	return nil
}

func init() {
	proto.RegisterType((*UpdateToLatestLedgerRequest)(nil), "types.UpdateToLatestLedgerRequest")
	proto.RegisterType((*RequestItem)(nil), "types.RequestItem")
	proto.RegisterType((*UpdateToLatestLedgerResponse)(nil), "types.UpdateToLatestLedgerResponse")
	proto.RegisterType((*ResponseItem)(nil), "types.ResponseItem")
	proto.RegisterType((*GetAccountStateRequest)(nil), "types.GetAccountStateRequest")
	proto.RegisterType((*GetAccountStateResponse)(nil), "types.GetAccountStateResponse")
	proto.RegisterType((*GetAccountTransactionBySequenceNumberRequest)(nil), "types.GetAccountTransactionBySequenceNumberRequest")
	proto.RegisterType((*GetAccountTransactionBySequenceNumberResponse)(nil), "types.GetAccountTransactionBySequenceNumberResponse")
	proto.RegisterType((*GetEventsByEventAccessPathRequest)(nil), "types.GetEventsByEventAccessPathRequest")
	proto.RegisterType((*GetEventsByEventAccessPathResponse)(nil), "types.GetEventsByEventAccessPathResponse")
	proto.RegisterType((*GetTransactionsRequest)(nil), "types.GetTransactionsRequest")
	proto.RegisterType((*GetTransactionsResponse)(nil), "types.GetTransactionsResponse")
}

func init() { proto.RegisterFile("get_with_proof.proto", fileDescriptor_5ffcd28ab9b25870) }

var fileDescriptor_5ffcd28ab9b25870 = []byte{
	// 1014 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xcf, 0x6f, 0x1b, 0x45,
	0x14, 0xf6, 0x24, 0x4e, 0x81, 0x67, 0x37, 0x89, 0x27, 0xbf, 0x4c, 0x48, 0x97, 0x64, 0x41, 0xaa,
	0x91, 0x9a, 0x08, 0x39, 0x3d, 0xc1, 0x29, 0xae, 0x10, 0xad, 0x88, 0xd2, 0x6a, 0xdd, 0x16, 0x81,
	0x8a, 0x56, 0xe3, 0xdd, 0xf1, 0x7a, 0x85, 0x3d, 0xeb, 0xee, 0x8c, 0xdd, 0xe6, 0x82, 0xe0, 0xc2,
	0xa9, 0x07, 0x0e, 0xdc, 0x91, 0x38, 0xf1, 0x27, 0x20, 0xfe, 0x02, 0x8e, 0x39, 0xf6, 0x48, 0x9c,
	0x0b, 0xc7, 0x5e, 0x11, 0x17, 0xb4, 0x33, 0xe3, 0xfd, 0x95, 0x0d, 0x8e, 0x4f, 0xf6, 0xcc, 0x7b,
	0xf3, 0xde, 0x37, 0xef, 0x7d, 0xdf, 0x9b, 0x85, 0x75, 0x8f, 0x0a, 0xfb, 0x85, 0x2f, 0x7a, 0xf6,
	0x30, 0x0c, 0x82, 0xee, 0xc1, 0x30, 0x0c, 0x44, 0x80, 0x97, 0xc4, 0xe9, 0x90, 0xf2, 0xed, 0x1a,
	0x71, 0x1c, 0xca, 0xb9, 0x3d, 0x24, 0xa2, 0xa7, 0x2c, 0xdb, 0x75, 0xe2, 0x38, 0xc1, 0x88, 0x09,
	0x9b, 0x0b, 0x22, 0xa8, 0xdd, 0xe9, 0x07, 0x1d, 0x6d, 0xa9, 0xd2, 0x31, 0x65, 0x82, 0xeb, 0x55,
	0xad, 0x4f, 0x5d, 0x8f, 0x86, 0xb6, 0xcf, 0xba, 0xc1, 0x74, 0x4b, 0x84, 0x84, 0x71, 0xe2, 0x08,
	0x3f, 0x60, 0x7a, 0x6b, 0x73, 0x4c, 0xfa, 0xbe, 0x4b, 0x44, 0x10, 0xda, 0x4e, 0x8f, 0x30, 0x8f,
	0xaa, 0x7d, 0xf3, 0x15, 0x82, 0xf7, 0x9e, 0x0c, 0x5d, 0x22, 0xe8, 0xe3, 0xe0, 0x98, 0x08, 0xca,
	0xc5, 0xb1, 0x0c, 0x67, 0xd1, 0xe7, 0x23, 0xca, 0x05, 0xfe, 0x18, 0xd6, 0x9d, 0xbe, 0x4f, 0x99,
	0xb0, 0xbf, 0x65, 0xc1, 0x0b, 0x66, 0x8f, 0x69, 0xc8, 0xfd, 0x80, 0xd5, 0xd1, 0x2e, 0x6a, 0x94,
	0x2d, 0xac, 0x6c, 0x5f, 0x44, 0xa6, 0xa7, 0xca, 0x82, 0x3f, 0x85, 0x95, 0x50, 0x1d, 0xa6, 0xae,
	0xed, 0x0b, 0x3a, 0xe0, 0xf5, 0x85, 0xdd, 0xc5, 0x46, 0xa5, 0x89, 0x0f, 0xe4, 0x5d, 0x0f, 0x74,
	0xe8, 0x07, 0x82, 0x0e, 0xac, 0xe5, 0xd8, 0x35, 0x5a, 0x72, 0xf3, 0x9f, 0x45, 0xa8, 0xa4, 0xec,
	0xf8, 0x6b, 0x78, 0x37, 0x2a, 0x5b, 0xb6, 0x14, 0xfa, 0x8c, 0xc4, 0x50, 0x69, 0xde, 0xd2, 0x61,
	0x3f, 0xa7, 0xe2, 0x48, 0xb9, 0xb5, 0x23, 0x2f, 0x1d, 0xe5, 0x7e, 0xc9, 0xda, 0xf4, 0x0a, 0x2d,
	0xf8, 0x17, 0x04, 0xcd, 0x74, 0xf0, 0x54, 0xd1, 0xec, 0xce, 0xa9, 0xcd, 0x23, 0x37, 0xe6, 0x50,
	0x9b, 0x8d, 0x06, 0x1d, 0x1a, 0xc6, 0x59, 0x17, 0x64, 0xd6, 0xc3, 0x4b, 0x59, 0x1f, 0x27, 0xc7,
	0x5b, 0xa7, 0x6d, 0x7d, 0xf8, 0x44, 0x9e, 0x4d, 0xb0, 0xdc, 0xf1, 0xe6, 0xf0, 0xc7, 0xdf, 0xc1,
	0xed, 0x08, 0xa0, 0x6a, 0x77, 0x84, 0x49, 0xfe, 0xb3, 0x53, 0x5c, 0x89, 0x51, 0x2d, 0x4a, 0x54,
	0x8d, 0x04, 0xd5, 0x67, 0xf2, 0x50, 0xeb, 0x54, 0xfe, 0x1e, 0xc9, 0x13, 0x8f, 0x88, 0xe8, 0x25,
	0x50, 0xf6, 0xbc, 0x59, 0x4e, 0xf8, 0x2b, 0xa8, 0x47, 0xf9, 0x53, 0x85, 0xe1, 0x71, 0xc2, 0x72,
	0xbe, 0xf8, 0xa9, 0xfb, 0xf0, 0x6c, 0xf1, 0x0b, 0x2c, 0xad, 0xda, 0x25, 0x96, 0x98, 0xaf, 0x16,
	0x60, 0xa7, 0x98, 0x8a, 0x7c, 0x18, 0x30, 0x4e, 0xf1, 0x27, 0xb0, 0x1c, 0xea, 0xff, 0x9a, 0x58,
	0x48, 0x12, 0x6b, 0x2d, 0x26, 0x96, 0x32, 0x4a, 0x66, 0xdd, 0x0c, 0x53, 0x2b, 0x8e, 0x2d, 0xd8,
	0x48, 0xe9, 0x44, 0xe9, 0x90, 0xfb, 0x1e, 0xd7, 0xed, 0x7c, 0x5f, 0x87, 0x50, 0x19, 0x1f, 0xb0,
	0x6e, 0xf0, 0xa5, 0x2f, 0x7a, 0x6d, 0xdf, 0x63, 0x44, 0x8c, 0x42, 0xca, 0x2d, 0xdc, 0xcf, 0x5b,
	0x38, 0x7e, 0x06, 0x5b, 0x79, 0x55, 0xe9, 0x5e, 0xd5, 0x17, 0x25, 0xb0, 0x0f, 0x75, 0xd4, 0xa7,
	0x53, 0xaf, 0x7b, 0xd2, 0x49, 0x56, 0x3b, 0x8a, 0xf2, 0x28, 0x1a, 0x04, 0xd6, 0xc6, 0xb8, 0xc0,
	0xcc, 0xcd, 0x1f, 0xcb, 0x50, 0x4d, 0xdf, 0x08, 0x7f, 0x03, 0xdb, 0x45, 0x5a, 0x50, 0x1e, 0x9a,
	0x00, 0xc6, 0x55, 0x62, 0x50, 0x5e, 0xf7, 0x4b, 0xd6, 0x96, 0x57, 0x6c, 0xc2, 0xbf, 0x22, 0x38,
	0x9c, 0x4b, 0x0e, 0x3a, 0xb1, 0x22, 0xc2, 0xdd, 0xf9, 0xf4, 0x10, 0xc3, 0xd9, 0xf7, 0xe6, 0x39,
	0x80, 0x7f, 0x40, 0xd0, 0x98, 0x2d, 0x09, 0x8d, 0x6c, 0x49, 0x22, 0xfb, 0xe8, 0x1a, 0x9a, 0x88,
	0xe1, 0x98, 0xde, 0x4c, 0x2f, 0xfc, 0x4c, 0xcd, 0xa4, 0x9c, 0x2a, 0x74, 0xce, 0x1b, 0xf9, 0x36,
	0x64, 0xc9, 0x9f, 0x69, 0x43, 0x91, 0xa9, 0xb5, 0x9a, 0x27, 0xb9, 0xd9, 0x84, 0xcd, 0xe2, 0xd9,
	0x86, 0xeb, 0xf0, 0x16, 0x71, 0xdd, 0x90, 0x72, 0x2e, 0x67, 0x61, 0xd5, 0x9a, 0x2e, 0xcd, 0x21,
	0x6c, 0x5d, 0x41, 0x01, 0xfc, 0x04, 0x72, 0x2f, 0x4b, 0xf2, 0x26, 0xe9, 0x89, 0xba, 0xa3, 0xd1,
	0xa7, 0x8f, 0xa7, 0xe8, 0x4a, 0x8a, 0xb6, 0xcd, 0x9f, 0x11, 0xdc, 0x99, 0x67, 0x18, 0x4a, 0xf0,
	0xca, 0x39, 0x06, 0xaf, 0x96, 0xf8, 0x36, 0xac, 0xe4, 0xd8, 0x26, 0x55, 0x5a, 0xb6, 0x96, 0x79,
	0x26, 0x12, 0xde, 0x83, 0x6a, 0x97, 0x0a, 0xa7, 0x97, 0xa8, 0x0e, 0x35, 0xde, 0xb6, 0x2a, 0x72,
	0x4f, 0xab, 0xe8, 0x5f, 0x04, 0xfb, 0x73, 0x71, 0x12, 0xbb, 0x70, 0x8b, 0xfb, 0x1e, 0xa3, 0x6e,
	0x46, 0x01, 0xa9, 0x22, 0xa9, 0x89, 0xb1, 0xa7, 0x8b, 0xd4, 0x96, 0xbe, 0xa9, 0xc0, 0x49, 0xa5,
	0xb6, 0xf9, 0x95, 0x36, 0xec, 0xc2, 0xae, 0x8c, 0x66, 0x07, 0x5d, 0xdb, 0x19, 0x85, 0x61, 0x44,
	0xe2, 0xfc, 0xa5, 0x17, 0xaf, 0xd1, 0x8d, 0x1d, 0x19, 0xe5, 0x61, 0xf7, 0x9e, 0x8a, 0x91, 0xbd,
	0x93, 0xf9, 0x07, 0x82, 0xbd, 0x99, 0x6f, 0x01, 0x6e, 0x42, 0x25, 0xa5, 0x1f, 0x4d, 0x82, 0x5a,
	0x92, 0x76, 0xea, 0x0e, 0x24, 0xfe, 0x8f, 0xf7, 0x61, 0x8d, 0x0b, 0x12, 0x6a, 0x25, 0x46, 0xd0,
	0x23, 0xd4, 0xba, 0x4f, 0xab, 0xd2, 0x24, 0xb3, 0xb5, 0xe9, 0xf3, 0x93, 0xd1, 0x00, 0xef, 0xc0,
	0x3b, 0x84, 0x3b, 0x94, 0xb9, 0x3e, 0xf3, 0x74, 0x9b, 0x92, 0x0d, 0xbc, 0x0e, 0x4b, 0x7d, 0x7f,
	0xe0, 0xab, 0x47, 0xa5, 0x6c, 0xa9, 0x85, 0xf9, 0x3b, 0x02, 0x73, 0xb6, 0x68, 0xf1, 0x11, 0xd4,
	0xf4, 0x34, 0xc8, 0x10, 0x39, 0x9a, 0xbf, 0x1b, 0xfa, 0x0e, 0xb9, 0x81, 0xbb, 0xa2, 0xfc, 0x93,
	0x66, 0x3c, 0x84, 0x8d, 0xb8, 0x19, 0x7d, 0xf9, 0xf2, 0xa8, 0x6b, 0xe9, 0x56, 0xff, 0x7f, 0x07,
	0xb0, 0xee, 0x80, 0x7a, 0xb2, 0x64, 0x2a, 0x73, 0x2c, 0x25, 0x5b, 0xf0, 0xee, 0xe1, 0x0f, 0xe0,
	0xa6, 0xaa, 0x5b, 0xf6, 0x43, 0xaa, 0x2a, 0x37, 0xa7, 0x9f, 0x50, 0x71, 0x3d, 0x16, 0x52, 0xf5,
	0xb8, 0x0e, 0xdb, 0x7d, 0x29, 0xfb, 0xa2, 0xb9, 0x82, 0x4f, 0x60, 0x4d, 0xbc, 0x64, 0x76, 0xdf,
	0xe7, 0xe2, 0xb2, 0xe2, 0xa7, 0xcf, 0x5f, 0xea, 0xe4, 0xb1, 0xcf, 0x53, 0x25, 0x5b, 0x15, 0x2f,
	0xb3, 0x3b, 0xad, 0xbb, 0x67, 0xe7, 0x46, 0xe9, 0xf5, 0xb9, 0x51, 0x7a, 0x73, 0x6e, 0xa0, 0xef,
	0x27, 0x06, 0xfa, 0x6d, 0x62, 0xa0, 0x3f, 0x27, 0x06, 0x3a, 0x9b, 0x18, 0xe8, 0xaf, 0x89, 0x81,
	0xfe, 0x9e, 0x18, 0xa5, 0x37, 0x13, 0x03, 0xfd, 0x74, 0x61, 0x94, 0xce, 0x2e, 0x8c, 0xd2, 0xeb,
	0x0b, 0xa3, 0xd4, 0xb9, 0x21, 0xbf, 0x3a, 0x0f, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x8a, 0xf0,
	0x20, 0x83, 0x0d, 0x0b, 0x00, 0x00,
}

func (this *UpdateToLatestLedgerRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateToLatestLedgerRequest)
	if !ok {
		that2, ok := that.(UpdateToLatestLedgerRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientKnownVersion != that1.ClientKnownVersion {
		return false
	}
	if len(this.RequestedItems) != len(that1.RequestedItems) {
		return false
	}
	for i := range this.RequestedItems {
		if !this.RequestedItems[i].Equal(that1.RequestedItems[i]) {
			return false
		}
	}
	return true
}
func (this *RequestItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestItem)
	if !ok {
		that2, ok := that.(RequestItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.RequestedItems == nil {
		if this.RequestedItems != nil {
			return false
		}
	} else if this.RequestedItems == nil {
		return false
	} else if !this.RequestedItems.Equal(that1.RequestedItems) {
		return false
	}
	return true
}
func (this *RequestItem_GetAccountStateRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestItem_GetAccountStateRequest)
	if !ok {
		that2, ok := that.(RequestItem_GetAccountStateRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GetAccountStateRequest.Equal(that1.GetAccountStateRequest) {
		return false
	}
	return true
}
func (this *RequestItem_GetAccountTransactionBySequenceNumberRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestItem_GetAccountTransactionBySequenceNumberRequest)
	if !ok {
		that2, ok := that.(RequestItem_GetAccountTransactionBySequenceNumberRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GetAccountTransactionBySequenceNumberRequest.Equal(that1.GetAccountTransactionBySequenceNumberRequest) {
		return false
	}
	return true
}
func (this *RequestItem_GetEventsByEventAccessPathRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestItem_GetEventsByEventAccessPathRequest)
	if !ok {
		that2, ok := that.(RequestItem_GetEventsByEventAccessPathRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GetEventsByEventAccessPathRequest.Equal(that1.GetEventsByEventAccessPathRequest) {
		return false
	}
	return true
}
func (this *RequestItem_GetTransactionsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestItem_GetTransactionsRequest)
	if !ok {
		that2, ok := that.(RequestItem_GetTransactionsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GetTransactionsRequest.Equal(that1.GetTransactionsRequest) {
		return false
	}
	return true
}
func (this *UpdateToLatestLedgerResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateToLatestLedgerResponse)
	if !ok {
		that2, ok := that.(UpdateToLatestLedgerResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ResponseItems) != len(that1.ResponseItems) {
		return false
	}
	for i := range this.ResponseItems {
		if !this.ResponseItems[i].Equal(that1.ResponseItems[i]) {
			return false
		}
	}
	if !this.LedgerInfoWithSigs.Equal(that1.LedgerInfoWithSigs) {
		return false
	}
	if len(this.ValidatorChangeEvents) != len(that1.ValidatorChangeEvents) {
		return false
	}
	for i := range this.ValidatorChangeEvents {
		if !this.ValidatorChangeEvents[i].Equal(that1.ValidatorChangeEvents[i]) {
			return false
		}
	}
	return true
}
func (this *ResponseItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseItem)
	if !ok {
		that2, ok := that.(ResponseItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.ResponseItems == nil {
		if this.ResponseItems != nil {
			return false
		}
	} else if this.ResponseItems == nil {
		return false
	} else if !this.ResponseItems.Equal(that1.ResponseItems) {
		return false
	}
	return true
}
func (this *ResponseItem_GetAccountStateResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseItem_GetAccountStateResponse)
	if !ok {
		that2, ok := that.(ResponseItem_GetAccountStateResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GetAccountStateResponse.Equal(that1.GetAccountStateResponse) {
		return false
	}
	return true
}
func (this *ResponseItem_GetAccountTransactionBySequenceNumberResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseItem_GetAccountTransactionBySequenceNumberResponse)
	if !ok {
		that2, ok := that.(ResponseItem_GetAccountTransactionBySequenceNumberResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GetAccountTransactionBySequenceNumberResponse.Equal(that1.GetAccountTransactionBySequenceNumberResponse) {
		return false
	}
	return true
}
func (this *ResponseItem_GetEventsByEventAccessPathResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseItem_GetEventsByEventAccessPathResponse)
	if !ok {
		that2, ok := that.(ResponseItem_GetEventsByEventAccessPathResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GetEventsByEventAccessPathResponse.Equal(that1.GetEventsByEventAccessPathResponse) {
		return false
	}
	return true
}
func (this *ResponseItem_GetTransactionsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseItem_GetTransactionsResponse)
	if !ok {
		that2, ok := that.(ResponseItem_GetTransactionsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GetTransactionsResponse.Equal(that1.GetTransactionsResponse) {
		return false
	}
	return true
}
func (this *GetAccountStateRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetAccountStateRequest)
	if !ok {
		that2, ok := that.(GetAccountStateRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Address, that1.Address) {
		return false
	}
	return true
}
func (this *GetAccountStateResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetAccountStateResponse)
	if !ok {
		that2, ok := that.(GetAccountStateResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AccountStateWithProof.Equal(that1.AccountStateWithProof) {
		return false
	}
	return true
}
func (this *GetAccountTransactionBySequenceNumberRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetAccountTransactionBySequenceNumberRequest)
	if !ok {
		that2, ok := that.(GetAccountTransactionBySequenceNumberRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Account, that1.Account) {
		return false
	}
	if this.SequenceNumber != that1.SequenceNumber {
		return false
	}
	if this.FetchEvents != that1.FetchEvents {
		return false
	}
	return true
}
func (this *GetAccountTransactionBySequenceNumberResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetAccountTransactionBySequenceNumberResponse)
	if !ok {
		that2, ok := that.(GetAccountTransactionBySequenceNumberResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SignedTransactionWithProof.Equal(that1.SignedTransactionWithProof) {
		return false
	}
	if !this.ProofOfCurrentSequenceNumber.Equal(that1.ProofOfCurrentSequenceNumber) {
		return false
	}
	return true
}
func (this *GetEventsByEventAccessPathRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetEventsByEventAccessPathRequest)
	if !ok {
		that2, ok := that.(GetEventsByEventAccessPathRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AccessPath.Equal(that1.AccessPath) {
		return false
	}
	if this.StartEventSeqNum != that1.StartEventSeqNum {
		return false
	}
	if this.Ascending != that1.Ascending {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	return true
}
func (this *GetEventsByEventAccessPathResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetEventsByEventAccessPathResponse)
	if !ok {
		that2, ok := that.(GetEventsByEventAccessPathResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.EventsWithProof) != len(that1.EventsWithProof) {
		return false
	}
	for i := range this.EventsWithProof {
		if !this.EventsWithProof[i].Equal(that1.EventsWithProof[i]) {
			return false
		}
	}
	if !this.ProofOfLatestEvent.Equal(that1.ProofOfLatestEvent) {
		return false
	}
	return true
}
func (this *GetTransactionsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetTransactionsRequest)
	if !ok {
		that2, ok := that.(GetTransactionsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartVersion != that1.StartVersion {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if this.FetchEvents != that1.FetchEvents {
		return false
	}
	return true
}
func (this *GetTransactionsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GetTransactionsResponse)
	if !ok {
		that2, ok := that.(GetTransactionsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.TxnListWithProof.Equal(that1.TxnListWithProof) {
		return false
	}
	return true
}
func (this *UpdateToLatestLedgerRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&types.UpdateToLatestLedgerRequest{")
	s = append(s, "ClientKnownVersion: "+fmt.Sprintf("%#v", this.ClientKnownVersion)+",\n")
	if this.RequestedItems != nil {
		s = append(s, "RequestedItems: "+fmt.Sprintf("%#v", this.RequestedItems)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&types.RequestItem{")
	if this.RequestedItems != nil {
		s = append(s, "RequestedItems: "+fmt.Sprintf("%#v", this.RequestedItems)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestItem_GetAccountStateRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&types.RequestItem_GetAccountStateRequest{` +
		`GetAccountStateRequest:` + fmt.Sprintf("%#v", this.GetAccountStateRequest) + `}`}, ", ")
	return s
}
func (this *RequestItem_GetAccountTransactionBySequenceNumberRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&types.RequestItem_GetAccountTransactionBySequenceNumberRequest{` +
		`GetAccountTransactionBySequenceNumberRequest:` + fmt.Sprintf("%#v", this.GetAccountTransactionBySequenceNumberRequest) + `}`}, ", ")
	return s
}
func (this *RequestItem_GetEventsByEventAccessPathRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&types.RequestItem_GetEventsByEventAccessPathRequest{` +
		`GetEventsByEventAccessPathRequest:` + fmt.Sprintf("%#v", this.GetEventsByEventAccessPathRequest) + `}`}, ", ")
	return s
}
func (this *RequestItem_GetTransactionsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&types.RequestItem_GetTransactionsRequest{` +
		`GetTransactionsRequest:` + fmt.Sprintf("%#v", this.GetTransactionsRequest) + `}`}, ", ")
	return s
}
func (this *UpdateToLatestLedgerResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.UpdateToLatestLedgerResponse{")
	if this.ResponseItems != nil {
		s = append(s, "ResponseItems: "+fmt.Sprintf("%#v", this.ResponseItems)+",\n")
	}
	if this.LedgerInfoWithSigs != nil {
		s = append(s, "LedgerInfoWithSigs: "+fmt.Sprintf("%#v", this.LedgerInfoWithSigs)+",\n")
	}
	if this.ValidatorChangeEvents != nil {
		s = append(s, "ValidatorChangeEvents: "+fmt.Sprintf("%#v", this.ValidatorChangeEvents)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseItem) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&types.ResponseItem{")
	if this.ResponseItems != nil {
		s = append(s, "ResponseItems: "+fmt.Sprintf("%#v", this.ResponseItems)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseItem_GetAccountStateResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&types.ResponseItem_GetAccountStateResponse{` +
		`GetAccountStateResponse:` + fmt.Sprintf("%#v", this.GetAccountStateResponse) + `}`}, ", ")
	return s
}
func (this *ResponseItem_GetAccountTransactionBySequenceNumberResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&types.ResponseItem_GetAccountTransactionBySequenceNumberResponse{` +
		`GetAccountTransactionBySequenceNumberResponse:` + fmt.Sprintf("%#v", this.GetAccountTransactionBySequenceNumberResponse) + `}`}, ", ")
	return s
}
func (this *ResponseItem_GetEventsByEventAccessPathResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&types.ResponseItem_GetEventsByEventAccessPathResponse{` +
		`GetEventsByEventAccessPathResponse:` + fmt.Sprintf("%#v", this.GetEventsByEventAccessPathResponse) + `}`}, ", ")
	return s
}
func (this *ResponseItem_GetTransactionsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&types.ResponseItem_GetTransactionsResponse{` +
		`GetTransactionsResponse:` + fmt.Sprintf("%#v", this.GetTransactionsResponse) + `}`}, ", ")
	return s
}
func (this *GetAccountStateRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&types.GetAccountStateRequest{")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetAccountStateResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&types.GetAccountStateResponse{")
	if this.AccountStateWithProof != nil {
		s = append(s, "AccountStateWithProof: "+fmt.Sprintf("%#v", this.AccountStateWithProof)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetAccountTransactionBySequenceNumberRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.GetAccountTransactionBySequenceNumberRequest{")
	s = append(s, "Account: "+fmt.Sprintf("%#v", this.Account)+",\n")
	s = append(s, "SequenceNumber: "+fmt.Sprintf("%#v", this.SequenceNumber)+",\n")
	s = append(s, "FetchEvents: "+fmt.Sprintf("%#v", this.FetchEvents)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetAccountTransactionBySequenceNumberResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&types.GetAccountTransactionBySequenceNumberResponse{")
	if this.SignedTransactionWithProof != nil {
		s = append(s, "SignedTransactionWithProof: "+fmt.Sprintf("%#v", this.SignedTransactionWithProof)+",\n")
	}
	if this.ProofOfCurrentSequenceNumber != nil {
		s = append(s, "ProofOfCurrentSequenceNumber: "+fmt.Sprintf("%#v", this.ProofOfCurrentSequenceNumber)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetEventsByEventAccessPathRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&types.GetEventsByEventAccessPathRequest{")
	if this.AccessPath != nil {
		s = append(s, "AccessPath: "+fmt.Sprintf("%#v", this.AccessPath)+",\n")
	}
	s = append(s, "StartEventSeqNum: "+fmt.Sprintf("%#v", this.StartEventSeqNum)+",\n")
	s = append(s, "Ascending: "+fmt.Sprintf("%#v", this.Ascending)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetEventsByEventAccessPathResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&types.GetEventsByEventAccessPathResponse{")
	if this.EventsWithProof != nil {
		s = append(s, "EventsWithProof: "+fmt.Sprintf("%#v", this.EventsWithProof)+",\n")
	}
	if this.ProofOfLatestEvent != nil {
		s = append(s, "ProofOfLatestEvent: "+fmt.Sprintf("%#v", this.ProofOfLatestEvent)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetTransactionsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&types.GetTransactionsRequest{")
	s = append(s, "StartVersion: "+fmt.Sprintf("%#v", this.StartVersion)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	s = append(s, "FetchEvents: "+fmt.Sprintf("%#v", this.FetchEvents)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GetTransactionsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&types.GetTransactionsResponse{")
	if this.TxnListWithProof != nil {
		s = append(s, "TxnListWithProof: "+fmt.Sprintf("%#v", this.TxnListWithProof)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringGetWithProof(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *UpdateToLatestLedgerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateToLatestLedgerRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClientKnownVersion != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.ClientKnownVersion))
	}
	if len(m.RequestedItems) > 0 {
		for _, msg := range m.RequestedItems {
			dAtA[i] = 0x12
			i++
			i = encodeVarintGetWithProof(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RequestItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestedItems != nil {
		nn1, err1 := m.RequestedItems.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += nn1
	}
	return i, nil
}

func (m *RequestItem_GetAccountStateRequest) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GetAccountStateRequest != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.GetAccountStateRequest.Size()))
		n2, err2 := m.GetAccountStateRequest.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	return i, nil
}
func (m *RequestItem_GetAccountTransactionBySequenceNumberRequest) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GetAccountTransactionBySequenceNumberRequest != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.GetAccountTransactionBySequenceNumberRequest.Size()))
		n3, err3 := m.GetAccountTransactionBySequenceNumberRequest.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	return i, nil
}
func (m *RequestItem_GetEventsByEventAccessPathRequest) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GetEventsByEventAccessPathRequest != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.GetEventsByEventAccessPathRequest.Size()))
		n4, err4 := m.GetEventsByEventAccessPathRequest.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	return i, nil
}
func (m *RequestItem_GetTransactionsRequest) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GetTransactionsRequest != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.GetTransactionsRequest.Size()))
		n5, err5 := m.GetTransactionsRequest.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	return i, nil
}
func (m *UpdateToLatestLedgerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateToLatestLedgerResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResponseItems) > 0 {
		for _, msg := range m.ResponseItems {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGetWithProof(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LedgerInfoWithSigs != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.LedgerInfoWithSigs.Size()))
		n6, err6 := m.LedgerInfoWithSigs.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	if len(m.ValidatorChangeEvents) > 0 {
		for _, msg := range m.ValidatorChangeEvents {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintGetWithProof(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ResponseItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ResponseItems != nil {
		nn7, err7 := m.ResponseItems.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += nn7
	}
	return i, nil
}

func (m *ResponseItem_GetAccountStateResponse) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GetAccountStateResponse != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.GetAccountStateResponse.Size()))
		n8, err8 := m.GetAccountStateResponse.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	return i, nil
}
func (m *ResponseItem_GetAccountTransactionBySequenceNumberResponse) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GetAccountTransactionBySequenceNumberResponse != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.GetAccountTransactionBySequenceNumberResponse.Size()))
		n9, err9 := m.GetAccountTransactionBySequenceNumberResponse.MarshalTo(dAtA[i:])
		if err9 != nil {
			return 0, err9
		}
		i += n9
	}
	return i, nil
}
func (m *ResponseItem_GetEventsByEventAccessPathResponse) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GetEventsByEventAccessPathResponse != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.GetEventsByEventAccessPathResponse.Size()))
		n10, err10 := m.GetEventsByEventAccessPathResponse.MarshalTo(dAtA[i:])
		if err10 != nil {
			return 0, err10
		}
		i += n10
	}
	return i, nil
}
func (m *ResponseItem_GetTransactionsResponse) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GetTransactionsResponse != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.GetTransactionsResponse.Size()))
		n11, err11 := m.GetTransactionsResponse.MarshalTo(dAtA[i:])
		if err11 != nil {
			return 0, err11
		}
		i += n11
	}
	return i, nil
}
func (m *GetAccountStateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAccountStateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	return i, nil
}

func (m *GetAccountStateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAccountStateResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AccountStateWithProof != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.AccountStateWithProof.Size()))
		n12, err12 := m.AccountStateWithProof.MarshalTo(dAtA[i:])
		if err12 != nil {
			return 0, err12
		}
		i += n12
	}
	return i, nil
}

func (m *GetAccountTransactionBySequenceNumberRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAccountTransactionBySequenceNumberRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Account) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(len(m.Account)))
		i += copy(dAtA[i:], m.Account)
	}
	if m.SequenceNumber != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.SequenceNumber))
	}
	if m.FetchEvents {
		dAtA[i] = 0x18
		i++
		if m.FetchEvents {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetAccountTransactionBySequenceNumberResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAccountTransactionBySequenceNumberResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SignedTransactionWithProof != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.SignedTransactionWithProof.Size()))
		n13, err13 := m.SignedTransactionWithProof.MarshalTo(dAtA[i:])
		if err13 != nil {
			return 0, err13
		}
		i += n13
	}
	if m.ProofOfCurrentSequenceNumber != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.ProofOfCurrentSequenceNumber.Size()))
		n14, err14 := m.ProofOfCurrentSequenceNumber.MarshalTo(dAtA[i:])
		if err14 != nil {
			return 0, err14
		}
		i += n14
	}
	return i, nil
}

func (m *GetEventsByEventAccessPathRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetEventsByEventAccessPathRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AccessPath != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.AccessPath.Size()))
		n15, err15 := m.AccessPath.MarshalTo(dAtA[i:])
		if err15 != nil {
			return 0, err15
		}
		i += n15
	}
	if m.StartEventSeqNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.StartEventSeqNum))
	}
	if m.Ascending {
		dAtA[i] = 0x18
		i++
		if m.Ascending {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Limit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.Limit))
	}
	return i, nil
}

func (m *GetEventsByEventAccessPathResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetEventsByEventAccessPathResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EventsWithProof) > 0 {
		for _, msg := range m.EventsWithProof {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGetWithProof(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ProofOfLatestEvent != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.ProofOfLatestEvent.Size()))
		n16, err16 := m.ProofOfLatestEvent.MarshalTo(dAtA[i:])
		if err16 != nil {
			return 0, err16
		}
		i += n16
	}
	return i, nil
}

func (m *GetTransactionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransactionsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartVersion != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.StartVersion))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.Limit))
	}
	if m.FetchEvents {
		dAtA[i] = 0x18
		i++
		if m.FetchEvents {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetTransactionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransactionsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TxnListWithProof != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGetWithProof(dAtA, i, uint64(m.TxnListWithProof.Size()))
		n17, err17 := m.TxnListWithProof.MarshalTo(dAtA[i:])
		if err17 != nil {
			return 0, err17
		}
		i += n17
	}
	return i, nil
}

func encodeVarintGetWithProof(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *UpdateToLatestLedgerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientKnownVersion != 0 {
		n += 1 + sovGetWithProof(uint64(m.ClientKnownVersion))
	}
	if len(m.RequestedItems) > 0 {
		for _, e := range m.RequestedItems {
			l = e.Size()
			n += 1 + l + sovGetWithProof(uint64(l))
		}
	}
	return n
}

func (m *RequestItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestedItems != nil {
		n += m.RequestedItems.Size()
	}
	return n
}

func (m *RequestItem_GetAccountStateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GetAccountStateRequest != nil {
		l = m.GetAccountStateRequest.Size()
		n += 1 + l + sovGetWithProof(uint64(l))
	}
	return n
}
func (m *RequestItem_GetAccountTransactionBySequenceNumberRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GetAccountTransactionBySequenceNumberRequest != nil {
		l = m.GetAccountTransactionBySequenceNumberRequest.Size()
		n += 1 + l + sovGetWithProof(uint64(l))
	}
	return n
}
func (m *RequestItem_GetEventsByEventAccessPathRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GetEventsByEventAccessPathRequest != nil {
		l = m.GetEventsByEventAccessPathRequest.Size()
		n += 1 + l + sovGetWithProof(uint64(l))
	}
	return n
}
func (m *RequestItem_GetTransactionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GetTransactionsRequest != nil {
		l = m.GetTransactionsRequest.Size()
		n += 1 + l + sovGetWithProof(uint64(l))
	}
	return n
}
func (m *UpdateToLatestLedgerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ResponseItems) > 0 {
		for _, e := range m.ResponseItems {
			l = e.Size()
			n += 1 + l + sovGetWithProof(uint64(l))
		}
	}
	if m.LedgerInfoWithSigs != nil {
		l = m.LedgerInfoWithSigs.Size()
		n += 1 + l + sovGetWithProof(uint64(l))
	}
	if len(m.ValidatorChangeEvents) > 0 {
		for _, e := range m.ValidatorChangeEvents {
			l = e.Size()
			n += 1 + l + sovGetWithProof(uint64(l))
		}
	}
	return n
}

func (m *ResponseItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResponseItems != nil {
		n += m.ResponseItems.Size()
	}
	return n
}

func (m *ResponseItem_GetAccountStateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GetAccountStateResponse != nil {
		l = m.GetAccountStateResponse.Size()
		n += 1 + l + sovGetWithProof(uint64(l))
	}
	return n
}
func (m *ResponseItem_GetAccountTransactionBySequenceNumberResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GetAccountTransactionBySequenceNumberResponse != nil {
		l = m.GetAccountTransactionBySequenceNumberResponse.Size()
		n += 1 + l + sovGetWithProof(uint64(l))
	}
	return n
}
func (m *ResponseItem_GetEventsByEventAccessPathResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GetEventsByEventAccessPathResponse != nil {
		l = m.GetEventsByEventAccessPathResponse.Size()
		n += 1 + l + sovGetWithProof(uint64(l))
	}
	return n
}
func (m *ResponseItem_GetTransactionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GetTransactionsResponse != nil {
		l = m.GetTransactionsResponse.Size()
		n += 1 + l + sovGetWithProof(uint64(l))
	}
	return n
}
func (m *GetAccountStateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovGetWithProof(uint64(l))
	}
	return n
}

func (m *GetAccountStateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccountStateWithProof != nil {
		l = m.AccountStateWithProof.Size()
		n += 1 + l + sovGetWithProof(uint64(l))
	}
	return n
}

func (m *GetAccountTransactionBySequenceNumberRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovGetWithProof(uint64(l))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovGetWithProof(uint64(m.SequenceNumber))
	}
	if m.FetchEvents {
		n += 2
	}
	return n
}

func (m *GetAccountTransactionBySequenceNumberResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignedTransactionWithProof != nil {
		l = m.SignedTransactionWithProof.Size()
		n += 1 + l + sovGetWithProof(uint64(l))
	}
	if m.ProofOfCurrentSequenceNumber != nil {
		l = m.ProofOfCurrentSequenceNumber.Size()
		n += 1 + l + sovGetWithProof(uint64(l))
	}
	return n
}

func (m *GetEventsByEventAccessPathRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AccessPath != nil {
		l = m.AccessPath.Size()
		n += 1 + l + sovGetWithProof(uint64(l))
	}
	if m.StartEventSeqNum != 0 {
		n += 1 + sovGetWithProof(uint64(m.StartEventSeqNum))
	}
	if m.Ascending {
		n += 2
	}
	if m.Limit != 0 {
		n += 1 + sovGetWithProof(uint64(m.Limit))
	}
	return n
}

func (m *GetEventsByEventAccessPathResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EventsWithProof) > 0 {
		for _, e := range m.EventsWithProof {
			l = e.Size()
			n += 1 + l + sovGetWithProof(uint64(l))
		}
	}
	if m.ProofOfLatestEvent != nil {
		l = m.ProofOfLatestEvent.Size()
		n += 1 + l + sovGetWithProof(uint64(l))
	}
	return n
}

func (m *GetTransactionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartVersion != 0 {
		n += 1 + sovGetWithProof(uint64(m.StartVersion))
	}
	if m.Limit != 0 {
		n += 1 + sovGetWithProof(uint64(m.Limit))
	}
	if m.FetchEvents {
		n += 2
	}
	return n
}

func (m *GetTransactionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxnListWithProof != nil {
		l = m.TxnListWithProof.Size()
		n += 1 + l + sovGetWithProof(uint64(l))
	}
	return n
}

func sovGetWithProof(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGetWithProof(x uint64) (n int) {
	return sovGetWithProof(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *UpdateToLatestLedgerRequest) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRequestedItems := "[]*RequestItem{"
	for _, f := range this.RequestedItems {
		repeatedStringForRequestedItems += strings.Replace(f.String(), "RequestItem", "RequestItem", 1) + ","
	}
	repeatedStringForRequestedItems += "}"
	s := strings.Join([]string{`&UpdateToLatestLedgerRequest{`,
		`ClientKnownVersion:` + fmt.Sprintf("%v", this.ClientKnownVersion) + `,`,
		`RequestedItems:` + repeatedStringForRequestedItems + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestItem{`,
		`RequestedItems:` + fmt.Sprintf("%v", this.RequestedItems) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestItem_GetAccountStateRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestItem_GetAccountStateRequest{`,
		`GetAccountStateRequest:` + strings.Replace(fmt.Sprintf("%v", this.GetAccountStateRequest), "GetAccountStateRequest", "GetAccountStateRequest", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestItem_GetAccountTransactionBySequenceNumberRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestItem_GetAccountTransactionBySequenceNumberRequest{`,
		`GetAccountTransactionBySequenceNumberRequest:` + strings.Replace(fmt.Sprintf("%v", this.GetAccountTransactionBySequenceNumberRequest), "GetAccountTransactionBySequenceNumberRequest", "GetAccountTransactionBySequenceNumberRequest", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestItem_GetEventsByEventAccessPathRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestItem_GetEventsByEventAccessPathRequest{`,
		`GetEventsByEventAccessPathRequest:` + strings.Replace(fmt.Sprintf("%v", this.GetEventsByEventAccessPathRequest), "GetEventsByEventAccessPathRequest", "GetEventsByEventAccessPathRequest", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestItem_GetTransactionsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestItem_GetTransactionsRequest{`,
		`GetTransactionsRequest:` + strings.Replace(fmt.Sprintf("%v", this.GetTransactionsRequest), "GetTransactionsRequest", "GetTransactionsRequest", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateToLatestLedgerResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForResponseItems := "[]*ResponseItem{"
	for _, f := range this.ResponseItems {
		repeatedStringForResponseItems += strings.Replace(f.String(), "ResponseItem", "ResponseItem", 1) + ","
	}
	repeatedStringForResponseItems += "}"
	repeatedStringForValidatorChangeEvents := "[]*ValidatorChangeEventWithProof{"
	for _, f := range this.ValidatorChangeEvents {
		repeatedStringForValidatorChangeEvents += strings.Replace(fmt.Sprintf("%v", f), "ValidatorChangeEventWithProof", "ValidatorChangeEventWithProof", 1) + ","
	}
	repeatedStringForValidatorChangeEvents += "}"
	s := strings.Join([]string{`&UpdateToLatestLedgerResponse{`,
		`ResponseItems:` + repeatedStringForResponseItems + `,`,
		`LedgerInfoWithSigs:` + strings.Replace(fmt.Sprintf("%v", this.LedgerInfoWithSigs), "LedgerInfoWithSignatures", "LedgerInfoWithSignatures", 1) + `,`,
		`ValidatorChangeEvents:` + repeatedStringForValidatorChangeEvents + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseItem) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseItem{`,
		`ResponseItems:` + fmt.Sprintf("%v", this.ResponseItems) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseItem_GetAccountStateResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseItem_GetAccountStateResponse{`,
		`GetAccountStateResponse:` + strings.Replace(fmt.Sprintf("%v", this.GetAccountStateResponse), "GetAccountStateResponse", "GetAccountStateResponse", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseItem_GetAccountTransactionBySequenceNumberResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseItem_GetAccountTransactionBySequenceNumberResponse{`,
		`GetAccountTransactionBySequenceNumberResponse:` + strings.Replace(fmt.Sprintf("%v", this.GetAccountTransactionBySequenceNumberResponse), "GetAccountTransactionBySequenceNumberResponse", "GetAccountTransactionBySequenceNumberResponse", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseItem_GetEventsByEventAccessPathResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseItem_GetEventsByEventAccessPathResponse{`,
		`GetEventsByEventAccessPathResponse:` + strings.Replace(fmt.Sprintf("%v", this.GetEventsByEventAccessPathResponse), "GetEventsByEventAccessPathResponse", "GetEventsByEventAccessPathResponse", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseItem_GetTransactionsResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseItem_GetTransactionsResponse{`,
		`GetTransactionsResponse:` + strings.Replace(fmt.Sprintf("%v", this.GetTransactionsResponse), "GetTransactionsResponse", "GetTransactionsResponse", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetAccountStateRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetAccountStateRequest{`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetAccountStateResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetAccountStateResponse{`,
		`AccountStateWithProof:` + strings.Replace(fmt.Sprintf("%v", this.AccountStateWithProof), "AccountStateWithProof", "AccountStateWithProof", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetAccountTransactionBySequenceNumberRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetAccountTransactionBySequenceNumberRequest{`,
		`Account:` + fmt.Sprintf("%v", this.Account) + `,`,
		`SequenceNumber:` + fmt.Sprintf("%v", this.SequenceNumber) + `,`,
		`FetchEvents:` + fmt.Sprintf("%v", this.FetchEvents) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetAccountTransactionBySequenceNumberResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetAccountTransactionBySequenceNumberResponse{`,
		`SignedTransactionWithProof:` + strings.Replace(fmt.Sprintf("%v", this.SignedTransactionWithProof), "SignedTransactionWithProof", "SignedTransactionWithProof", 1) + `,`,
		`ProofOfCurrentSequenceNumber:` + strings.Replace(fmt.Sprintf("%v", this.ProofOfCurrentSequenceNumber), "AccountStateWithProof", "AccountStateWithProof", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetEventsByEventAccessPathRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetEventsByEventAccessPathRequest{`,
		`AccessPath:` + strings.Replace(fmt.Sprintf("%v", this.AccessPath), "AccessPath", "AccessPath", 1) + `,`,
		`StartEventSeqNum:` + fmt.Sprintf("%v", this.StartEventSeqNum) + `,`,
		`Ascending:` + fmt.Sprintf("%v", this.Ascending) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetEventsByEventAccessPathResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForEventsWithProof := "[]*EventWithProof{"
	for _, f := range this.EventsWithProof {
		repeatedStringForEventsWithProof += strings.Replace(fmt.Sprintf("%v", f), "EventWithProof", "EventWithProof", 1) + ","
	}
	repeatedStringForEventsWithProof += "}"
	s := strings.Join([]string{`&GetEventsByEventAccessPathResponse{`,
		`EventsWithProof:` + repeatedStringForEventsWithProof + `,`,
		`ProofOfLatestEvent:` + strings.Replace(fmt.Sprintf("%v", this.ProofOfLatestEvent), "AccountStateWithProof", "AccountStateWithProof", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetTransactionsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetTransactionsRequest{`,
		`StartVersion:` + fmt.Sprintf("%v", this.StartVersion) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`FetchEvents:` + fmt.Sprintf("%v", this.FetchEvents) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GetTransactionsResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GetTransactionsResponse{`,
		`TxnListWithProof:` + strings.Replace(fmt.Sprintf("%v", this.TxnListWithProof), "TransactionListWithProof", "TransactionListWithProof", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringGetWithProof(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *UpdateToLatestLedgerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGetWithProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateToLatestLedgerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateToLatestLedgerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientKnownVersion", wireType)
			}
			m.ClientKnownVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientKnownVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestedItems = append(m.RequestedItems, &RequestItem{})
			if err := m.RequestedItems[len(m.RequestedItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGetWithProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGetWithProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetAccountStateRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetAccountStateRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RequestedItems = &RequestItem_GetAccountStateRequest{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetAccountTransactionBySequenceNumberRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetAccountTransactionBySequenceNumberRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RequestedItems = &RequestItem_GetAccountTransactionBySequenceNumberRequest{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetEventsByEventAccessPathRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetEventsByEventAccessPathRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RequestedItems = &RequestItem_GetEventsByEventAccessPathRequest{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetTransactionsRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetTransactionsRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.RequestedItems = &RequestItem_GetTransactionsRequest{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGetWithProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateToLatestLedgerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGetWithProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateToLatestLedgerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateToLatestLedgerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseItems = append(m.ResponseItems, &ResponseItem{})
			if err := m.ResponseItems[len(m.ResponseItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerInfoWithSigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LedgerInfoWithSigs == nil {
				m.LedgerInfoWithSigs = &LedgerInfoWithSignatures{}
			}
			if err := m.LedgerInfoWithSigs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorChangeEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorChangeEvents = append(m.ValidatorChangeEvents, &ValidatorChangeEventWithProof{})
			if err := m.ValidatorChangeEvents[len(m.ValidatorChangeEvents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGetWithProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGetWithProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetAccountStateResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetAccountStateResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResponseItems = &ResponseItem_GetAccountStateResponse{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetAccountTransactionBySequenceNumberResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetAccountTransactionBySequenceNumberResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResponseItems = &ResponseItem_GetAccountTransactionBySequenceNumberResponse{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetEventsByEventAccessPathResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetEventsByEventAccessPathResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResponseItems = &ResponseItem_GetEventsByEventAccessPathResponse{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetTransactionsResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GetTransactionsResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ResponseItems = &ResponseItem_GetTransactionsResponse{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGetWithProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAccountStateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGetWithProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAccountStateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAccountStateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGetWithProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAccountStateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGetWithProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAccountStateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAccountStateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountStateWithProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccountStateWithProof == nil {
				m.AccountStateWithProof = &AccountStateWithProof{}
			}
			if err := m.AccountStateWithProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGetWithProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAccountTransactionBySequenceNumberRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGetWithProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAccountTransactionBySequenceNumberRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAccountTransactionBySequenceNumberRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = append(m.Account[:0], dAtA[iNdEx:postIndex]...)
			if m.Account == nil {
				m.Account = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FetchEvents", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FetchEvents = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGetWithProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAccountTransactionBySequenceNumberResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGetWithProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAccountTransactionBySequenceNumberResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAccountTransactionBySequenceNumberResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedTransactionWithProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignedTransactionWithProof == nil {
				m.SignedTransactionWithProof = &SignedTransactionWithProof{}
			}
			if err := m.SignedTransactionWithProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofOfCurrentSequenceNumber", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofOfCurrentSequenceNumber == nil {
				m.ProofOfCurrentSequenceNumber = &AccountStateWithProof{}
			}
			if err := m.ProofOfCurrentSequenceNumber.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGetWithProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetEventsByEventAccessPathRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGetWithProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetEventsByEventAccessPathRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetEventsByEventAccessPathRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessPath", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccessPath == nil {
				m.AccessPath = &AccessPath{}
			}
			if err := m.AccessPath.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartEventSeqNum", wireType)
			}
			m.StartEventSeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartEventSeqNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ascending", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ascending = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGetWithProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetEventsByEventAccessPathResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGetWithProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetEventsByEventAccessPathResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetEventsByEventAccessPathResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventsWithProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventsWithProof = append(m.EventsWithProof, &EventWithProof{})
			if err := m.EventsWithProof[len(m.EventsWithProof)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofOfLatestEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofOfLatestEvent == nil {
				m.ProofOfLatestEvent = &AccountStateWithProof{}
			}
			if err := m.ProofOfLatestEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGetWithProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransactionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGetWithProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransactionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransactionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartVersion", wireType)
			}
			m.StartVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FetchEvents", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FetchEvents = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGetWithProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransactionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGetWithProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransactionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransactionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnListWithProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGetWithProof
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxnListWithProof == nil {
				m.TxnListWithProof = &TransactionListWithProof{}
			}
			if err := m.TxnListWithProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGetWithProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGetWithProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGetWithProof(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGetWithProof
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGetWithProof
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGetWithProof
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthGetWithProof
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGetWithProof
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGetWithProof(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthGetWithProof
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGetWithProof = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGetWithProof   = fmt.Errorf("proto: integer overflow")
)
