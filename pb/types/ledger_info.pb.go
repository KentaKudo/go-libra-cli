// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ledger_info.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

/// Even though we don't always need all hashes, we pass them in and return them
/// always so that we keep them in sync on the client and don't make the client
/// worry about which one(s) to pass in which cases
///
/// This structure serves a dual purpose.
///
/// First, if this structure is signed by 2f+1 validators it signifies the state
/// of the ledger at version `version` -- it contains the transaction
/// accumulator at that version which commits to all historical transactions.
/// This structure may be expanded to include other information that is derived
/// from that accumulator (e.g. the current time according to the time contract)
/// to reduce the number of proofs a client must get.
///
/// Second, the structure contains a `consensus_data_hash` value. This is the
/// hash of an internal data structure that represents a block that is voted on
/// by consensus.
///
/// Combining these two concepts when the consensus algorithm votes on a block B
/// it votes for a LedgerInfo with the `version` being the latest version that
/// will be committed if B gets 2f+1 votes. It sets `consensus_data_hash` to
/// represent B so that if those 2f+1 votes are gathered, the block is valid to
/// commit
type LedgerInfo struct {
	// Current latest version of the system
	Version uint64 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	// Root hash of transaction accumulator at this version
	TransactionAccumulatorHash []byte `protobuf:"bytes,2,opt,name=transaction_accumulator_hash,json=transactionAccumulatorHash,proto3" json:"transaction_accumulator_hash,omitempty"`
	// Hash of consensus-specific data that is opaque to all parts of the system
	// other than consensus.  This is needed to verify signatures because
	// consensus signing includes this hash
	ConsensusDataHash []byte `protobuf:"bytes,3,opt,name=consensus_data_hash,json=consensusDataHash,proto3" json:"consensus_data_hash,omitempty"`
	// The block id of the last committed block corresponding to this ledger info.
	// This field is not particularly interesting to the clients, but can be used
	// by the validators for synchronization.
	ConsensusBlockId []byte `protobuf:"bytes,4,opt,name=consensus_block_id,json=consensusBlockId,proto3" json:"consensus_block_id,omitempty"`
	// Epoch number corresponds to the set of validators that are active for this
	// ledger info. The main motivation for keeping the epoch number in the
	// LedgerInfo is to ensure that the client has enough information to verify
	// that the signatures for this info are coming from the validators that
	// indeed form a quorum. Without epoch number a potential attack could reuse
	// the signatures from the validators in one epoch in order to sign the wrong
	// info belonging to another epoch, in which these validators do not form a
	// quorum. The very first epoch number is 0.
	EpochNum uint64 `protobuf:"varint,5,opt,name=epoch_num,json=epochNum,proto3" json:"epoch_num,omitempty"`
	// Timestamp that represents the microseconds since the epoch (unix time) that is
	// generated by the proposer of the block.  This is strictly increasing with every block.
	// If a client reads a timestamp > the one they specified for transaction expiration time,
	// they can be certain that their transaction will never be included in a block in the future
	// (assuming that their transaction has not yet been included)
	TimestampUsecs uint64 `protobuf:"varint,6,opt,name=timestamp_usecs,json=timestampUsecs,proto3" json:"timestamp_usecs,omitempty"`
}

func (m *LedgerInfo) Reset()      { *m = LedgerInfo{} }
func (*LedgerInfo) ProtoMessage() {}
func (*LedgerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a2c689d95021ed, []int{0}
}
func (m *LedgerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerInfo.Merge(m, src)
}
func (m *LedgerInfo) XXX_Size() int {
	return m.Size()
}
func (m *LedgerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerInfo proto.InternalMessageInfo

func (m *LedgerInfo) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *LedgerInfo) GetTransactionAccumulatorHash() []byte {
	if m != nil {
		return m.TransactionAccumulatorHash
	}
	return nil
}

func (m *LedgerInfo) GetConsensusDataHash() []byte {
	if m != nil {
		return m.ConsensusDataHash
	}
	return nil
}

func (m *LedgerInfo) GetConsensusBlockId() []byte {
	if m != nil {
		return m.ConsensusBlockId
	}
	return nil
}

func (m *LedgerInfo) GetEpochNum() uint64 {
	if m != nil {
		return m.EpochNum
	}
	return 0
}

func (m *LedgerInfo) GetTimestampUsecs() uint64 {
	if m != nil {
		return m.TimestampUsecs
	}
	return 0
}

/// The validator node returns this structure which includes signatures
/// from each validator to confirm the state.  The client needs to only pass
/// back the LedgerInfo element since the validator node doesn't need to know
/// the signatures again when the client performs a query, those are only there
/// for the client to be able to verify the state
type LedgerInfoWithSignatures struct {
	// Signatures of the root node from each validator
	Signatures []*ValidatorSignature `protobuf:"bytes,1,rep,name=signatures,proto3" json:"signatures,omitempty"`
	LedgerInfo *LedgerInfo           `protobuf:"bytes,2,opt,name=ledger_info,json=ledgerInfo,proto3" json:"ledger_info,omitempty"`
}

func (m *LedgerInfoWithSignatures) Reset()      { *m = LedgerInfoWithSignatures{} }
func (*LedgerInfoWithSignatures) ProtoMessage() {}
func (*LedgerInfoWithSignatures) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a2c689d95021ed, []int{1}
}
func (m *LedgerInfoWithSignatures) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LedgerInfoWithSignatures) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LedgerInfoWithSignatures.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LedgerInfoWithSignatures) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LedgerInfoWithSignatures.Merge(m, src)
}
func (m *LedgerInfoWithSignatures) XXX_Size() int {
	return m.Size()
}
func (m *LedgerInfoWithSignatures) XXX_DiscardUnknown() {
	xxx_messageInfo_LedgerInfoWithSignatures.DiscardUnknown(m)
}

var xxx_messageInfo_LedgerInfoWithSignatures proto.InternalMessageInfo

func (m *LedgerInfoWithSignatures) GetSignatures() []*ValidatorSignature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

func (m *LedgerInfoWithSignatures) GetLedgerInfo() *LedgerInfo {
	if m != nil {
		return m.LedgerInfo
	}
	return nil
}

type ValidatorSignature struct {
	// The account address of the validator, which can be used for retrieving its
	// public key during the given epoch.
	ValidatorId []byte `protobuf:"bytes,1,opt,name=validator_id,json=validatorId,proto3" json:"validator_id,omitempty"`
	Signature   []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *ValidatorSignature) Reset()      { *m = ValidatorSignature{} }
func (*ValidatorSignature) ProtoMessage() {}
func (*ValidatorSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0a2c689d95021ed, []int{2}
}
func (m *ValidatorSignature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorSignature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorSignature.Merge(m, src)
}
func (m *ValidatorSignature) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorSignature.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorSignature proto.InternalMessageInfo

func (m *ValidatorSignature) GetValidatorId() []byte {
	if m != nil {
		return m.ValidatorId
	}
	return nil
}

func (m *ValidatorSignature) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func init() {
	proto.RegisterType((*LedgerInfo)(nil), "types.LedgerInfo")
	proto.RegisterType((*LedgerInfoWithSignatures)(nil), "types.LedgerInfoWithSignatures")
	proto.RegisterType((*ValidatorSignature)(nil), "types.ValidatorSignature")
}

func init() { proto.RegisterFile("ledger_info.proto", fileDescriptor_d0a2c689d95021ed) }

var fileDescriptor_d0a2c689d95021ed = []byte{
	// 392 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x92, 0xb1, 0xae, 0xd3, 0x30,
	0x14, 0x86, 0xe3, 0x7b, 0x6f, 0x0b, 0x3d, 0xa9, 0x80, 0x9a, 0xc5, 0x40, 0x65, 0x95, 0x2e, 0x74,
	0x40, 0x19, 0x0a, 0x0b, 0x1b, 0x54, 0x0c, 0x54, 0x42, 0x0c, 0x41, 0x85, 0x31, 0x72, 0x13, 0xb7,
	0xb1, 0x48, 0xec, 0x28, 0x76, 0x2a, 0xb1, 0xb1, 0x22, 0x31, 0xf0, 0x18, 0x3c, 0x0a, 0x63, 0xc7,
	0x8e, 0x34, 0x5d, 0x18, 0xfb, 0x08, 0x28, 0xa6, 0x75, 0x2a, 0xdd, 0x2d, 0xe7, 0xff, 0xbf, 0x93,
	0x63, 0xff, 0xc7, 0x30, 0xc8, 0x78, 0xb2, 0xe6, 0x65, 0x24, 0xe4, 0x4a, 0x05, 0x45, 0xa9, 0x8c,
	0xc2, 0x1d, 0xf3, 0xb5, 0xe0, 0x7a, 0xfc, 0xe3, 0x0a, 0xe0, 0xbd, 0x35, 0xe7, 0x72, 0xa5, 0x30,
	0x81, 0x3b, 0x1b, 0x5e, 0x6a, 0xa1, 0x24, 0x41, 0x23, 0x34, 0xb9, 0x09, 0xcf, 0x25, 0x7e, 0x0d,
	0x43, 0x53, 0x32, 0xa9, 0x59, 0x6c, 0x84, 0x92, 0x11, 0x8b, 0xe3, 0x2a, 0xaf, 0x32, 0x66, 0x54,
	0x19, 0xa5, 0x4c, 0xa7, 0xe4, 0x6a, 0x84, 0x26, 0xfd, 0xf0, 0xf1, 0x05, 0xf3, 0xa6, 0x45, 0xde,
	0x31, 0x9d, 0xe2, 0x00, 0x1e, 0xc6, 0x4a, 0x6a, 0x2e, 0x75, 0xa5, 0xa3, 0x84, 0x19, 0xf6, 0xbf,
	0xf1, 0xda, 0x36, 0x0e, 0x9c, 0xf5, 0x96, 0x19, 0x66, 0xf9, 0xe7, 0x80, 0x5b, 0x7e, 0x99, 0xa9,
	0xf8, 0x4b, 0x24, 0x12, 0x72, 0x63, 0xf1, 0x07, 0xce, 0x99, 0x35, 0xc6, 0x3c, 0xc1, 0x4f, 0xa0,
	0xc7, 0x0b, 0x15, 0xa7, 0x91, 0xac, 0x72, 0xd2, 0xb1, 0x67, 0xbf, 0x6b, 0x85, 0x0f, 0x55, 0x8e,
	0x9f, 0xc1, 0x7d, 0x23, 0x72, 0xae, 0x0d, 0xcb, 0x8b, 0xa8, 0xd2, 0x3c, 0xd6, 0xa4, 0x6b, 0x91,
	0x7b, 0x4e, 0x5e, 0x34, 0xea, 0xf8, 0x3b, 0x02, 0xd2, 0xc6, 0xf1, 0x59, 0x98, 0xf4, 0xa3, 0x58,
	0x4b, 0x66, 0xaa, 0x92, 0x6b, 0xfc, 0x0a, 0x40, 0xbb, 0x8a, 0xa0, 0xd1, 0xf5, 0xc4, 0x9f, 0x3e,
	0x0a, 0x6c, 0x8e, 0xc1, 0x27, 0x96, 0x89, 0xa4, 0xb9, 0xaa, 0xe3, 0xc3, 0x0b, 0x18, 0x4f, 0xc1,
	0xbf, 0x58, 0x81, 0x0d, 0xcb, 0x9f, 0x0e, 0x4e, 0xbd, 0xed, 0xc0, 0x10, 0x32, 0xf7, 0x3d, 0x5e,
	0x00, 0xbe, 0xfd, 0x57, 0xfc, 0x14, 0xfa, 0x9b, 0xb3, 0xda, 0xe4, 0x81, 0x6c, 0x1e, 0xbe, 0xd3,
	0xe6, 0x09, 0x1e, 0x42, 0xcf, 0x8d, 0x3e, 0xed, 0xa5, 0x15, 0x66, 0x2f, 0xb7, 0x7b, 0xea, 0xed,
	0xf6, 0xd4, 0x3b, 0xee, 0x29, 0xfa, 0x56, 0x53, 0xf4, 0xab, 0xa6, 0xe8, 0x77, 0x4d, 0xd1, 0xb6,
	0xa6, 0xe8, 0x4f, 0x4d, 0xd1, 0xdf, 0x9a, 0x7a, 0xc7, 0x9a, 0xa2, 0x9f, 0x07, 0xea, 0x6d, 0x0f,
	0xd4, 0xdb, 0x1d, 0xa8, 0xb7, 0xec, 0xda, 0x57, 0xf3, 0xe2, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x29, 0x97, 0x11, 0x52, 0x4a, 0x02, 0x00, 0x00,
}

func (this *LedgerInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LedgerInfo)
	if !ok {
		that2, ok := that.(LedgerInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !bytes.Equal(this.TransactionAccumulatorHash, that1.TransactionAccumulatorHash) {
		return false
	}
	if !bytes.Equal(this.ConsensusDataHash, that1.ConsensusDataHash) {
		return false
	}
	if !bytes.Equal(this.ConsensusBlockId, that1.ConsensusBlockId) {
		return false
	}
	if this.EpochNum != that1.EpochNum {
		return false
	}
	if this.TimestampUsecs != that1.TimestampUsecs {
		return false
	}
	return true
}
func (this *LedgerInfoWithSignatures) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LedgerInfoWithSignatures)
	if !ok {
		that2, ok := that.(LedgerInfoWithSignatures)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return false
	}
	for i := range this.Signatures {
		if !this.Signatures[i].Equal(that1.Signatures[i]) {
			return false
		}
	}
	if !this.LedgerInfo.Equal(that1.LedgerInfo) {
		return false
	}
	return true
}
func (this *ValidatorSignature) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValidatorSignature)
	if !ok {
		that2, ok := that.(ValidatorSignature)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.ValidatorId, that1.ValidatorId) {
		return false
	}
	if !bytes.Equal(this.Signature, that1.Signature) {
		return false
	}
	return true
}
func (this *LedgerInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&types.LedgerInfo{")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "TransactionAccumulatorHash: "+fmt.Sprintf("%#v", this.TransactionAccumulatorHash)+",\n")
	s = append(s, "ConsensusDataHash: "+fmt.Sprintf("%#v", this.ConsensusDataHash)+",\n")
	s = append(s, "ConsensusBlockId: "+fmt.Sprintf("%#v", this.ConsensusBlockId)+",\n")
	s = append(s, "EpochNum: "+fmt.Sprintf("%#v", this.EpochNum)+",\n")
	s = append(s, "TimestampUsecs: "+fmt.Sprintf("%#v", this.TimestampUsecs)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LedgerInfoWithSignatures) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&types.LedgerInfoWithSignatures{")
	if this.Signatures != nil {
		s = append(s, "Signatures: "+fmt.Sprintf("%#v", this.Signatures)+",\n")
	}
	if this.LedgerInfo != nil {
		s = append(s, "LedgerInfo: "+fmt.Sprintf("%#v", this.LedgerInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ValidatorSignature) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&types.ValidatorSignature{")
	s = append(s, "ValidatorId: "+fmt.Sprintf("%#v", this.ValidatorId)+",\n")
	s = append(s, "Signature: "+fmt.Sprintf("%#v", this.Signature)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringLedgerInfo(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *LedgerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLedgerInfo(dAtA, i, uint64(m.Version))
	}
	if len(m.TransactionAccumulatorHash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLedgerInfo(dAtA, i, uint64(len(m.TransactionAccumulatorHash)))
		i += copy(dAtA[i:], m.TransactionAccumulatorHash)
	}
	if len(m.ConsensusDataHash) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLedgerInfo(dAtA, i, uint64(len(m.ConsensusDataHash)))
		i += copy(dAtA[i:], m.ConsensusDataHash)
	}
	if len(m.ConsensusBlockId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLedgerInfo(dAtA, i, uint64(len(m.ConsensusBlockId)))
		i += copy(dAtA[i:], m.ConsensusBlockId)
	}
	if m.EpochNum != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintLedgerInfo(dAtA, i, uint64(m.EpochNum))
	}
	if m.TimestampUsecs != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintLedgerInfo(dAtA, i, uint64(m.TimestampUsecs))
	}
	return i, nil
}

func (m *LedgerInfoWithSignatures) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LedgerInfoWithSignatures) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for _, msg := range m.Signatures {
			dAtA[i] = 0xa
			i++
			i = encodeVarintLedgerInfo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LedgerInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLedgerInfo(dAtA, i, uint64(m.LedgerInfo.Size()))
		n1, err1 := m.LedgerInfo.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	return i, nil
}

func (m *ValidatorSignature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorSignature) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ValidatorId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLedgerInfo(dAtA, i, uint64(len(m.ValidatorId)))
		i += copy(dAtA[i:], m.ValidatorId)
	}
	if len(m.Signature) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLedgerInfo(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	return i, nil
}

func encodeVarintLedgerInfo(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *LedgerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovLedgerInfo(uint64(m.Version))
	}
	l = len(m.TransactionAccumulatorHash)
	if l > 0 {
		n += 1 + l + sovLedgerInfo(uint64(l))
	}
	l = len(m.ConsensusDataHash)
	if l > 0 {
		n += 1 + l + sovLedgerInfo(uint64(l))
	}
	l = len(m.ConsensusBlockId)
	if l > 0 {
		n += 1 + l + sovLedgerInfo(uint64(l))
	}
	if m.EpochNum != 0 {
		n += 1 + sovLedgerInfo(uint64(m.EpochNum))
	}
	if m.TimestampUsecs != 0 {
		n += 1 + sovLedgerInfo(uint64(m.TimestampUsecs))
	}
	return n
}

func (m *LedgerInfoWithSignatures) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovLedgerInfo(uint64(l))
		}
	}
	if m.LedgerInfo != nil {
		l = m.LedgerInfo.Size()
		n += 1 + l + sovLedgerInfo(uint64(l))
	}
	return n
}

func (m *ValidatorSignature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorId)
	if l > 0 {
		n += 1 + l + sovLedgerInfo(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovLedgerInfo(uint64(l))
	}
	return n
}

func sovLedgerInfo(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLedgerInfo(x uint64) (n int) {
	return sovLedgerInfo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *LedgerInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LedgerInfo{`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`TransactionAccumulatorHash:` + fmt.Sprintf("%v", this.TransactionAccumulatorHash) + `,`,
		`ConsensusDataHash:` + fmt.Sprintf("%v", this.ConsensusDataHash) + `,`,
		`ConsensusBlockId:` + fmt.Sprintf("%v", this.ConsensusBlockId) + `,`,
		`EpochNum:` + fmt.Sprintf("%v", this.EpochNum) + `,`,
		`TimestampUsecs:` + fmt.Sprintf("%v", this.TimestampUsecs) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LedgerInfoWithSignatures) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSignatures := "[]*ValidatorSignature{"
	for _, f := range this.Signatures {
		repeatedStringForSignatures += strings.Replace(f.String(), "ValidatorSignature", "ValidatorSignature", 1) + ","
	}
	repeatedStringForSignatures += "}"
	s := strings.Join([]string{`&LedgerInfoWithSignatures{`,
		`Signatures:` + repeatedStringForSignatures + `,`,
		`LedgerInfo:` + strings.Replace(this.LedgerInfo.String(), "LedgerInfo", "LedgerInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ValidatorSignature) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ValidatorSignature{`,
		`ValidatorId:` + fmt.Sprintf("%v", this.ValidatorId) + `,`,
		`Signature:` + fmt.Sprintf("%v", this.Signature) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringLedgerInfo(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *LedgerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedgerInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedgerInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionAccumulatorHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedgerInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLedgerInfo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLedgerInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionAccumulatorHash = append(m.TransactionAccumulatorHash[:0], dAtA[iNdEx:postIndex]...)
			if m.TransactionAccumulatorHash == nil {
				m.TransactionAccumulatorHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusDataHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedgerInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLedgerInfo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLedgerInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsensusDataHash = append(m.ConsensusDataHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ConsensusDataHash == nil {
				m.ConsensusDataHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusBlockId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedgerInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLedgerInfo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLedgerInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsensusBlockId = append(m.ConsensusBlockId[:0], dAtA[iNdEx:postIndex]...)
			if m.ConsensusBlockId == nil {
				m.ConsensusBlockId = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochNum", wireType)
			}
			m.EpochNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedgerInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampUsecs", wireType)
			}
			m.TimestampUsecs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedgerInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampUsecs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLedgerInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLedgerInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLedgerInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LedgerInfoWithSignatures) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedgerInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LedgerInfoWithSignatures: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LedgerInfoWithSignatures: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedgerInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedgerInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedgerInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, &ValidatorSignature{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LedgerInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedgerInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLedgerInfo
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLedgerInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LedgerInfo == nil {
				m.LedgerInfo = &LedgerInfo{}
			}
			if err := m.LedgerInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedgerInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLedgerInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLedgerInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorSignature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLedgerInfo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorSignature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorSignature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedgerInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLedgerInfo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLedgerInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorId = append(m.ValidatorId[:0], dAtA[iNdEx:postIndex]...)
			if m.ValidatorId == nil {
				m.ValidatorId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLedgerInfo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLedgerInfo
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLedgerInfo
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLedgerInfo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLedgerInfo
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthLedgerInfo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLedgerInfo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLedgerInfo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLedgerInfo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLedgerInfo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLedgerInfo
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthLedgerInfo
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLedgerInfo
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLedgerInfo(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthLedgerInfo
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLedgerInfo = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLedgerInfo   = fmt.Errorf("proto: integer overflow")
)
