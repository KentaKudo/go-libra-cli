// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: admission_control.proto

package admission_control

import (
	bytes "bytes"
	fmt "fmt"
	mempool "github.com/KentaKudo/go-libra-cli/pb/mempool"
	types "github.com/KentaKudo/go-libra-cli/pb/types"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Additional statuses that are possible from admission control in addition
// to VM statuses.
type AdmissionControlStatusCode int32

const (
	// Validator accepted the transaction.
	Accepted AdmissionControlStatusCode = 0
	// The sender is blacklisted.
	Blacklisted AdmissionControlStatusCode = 1
	// The transaction is rejected, e.g. due to incorrect signature.
	Rejected AdmissionControlStatusCode = 2
)

var AdmissionControlStatusCode_name = map[int32]string{
	0: "Accepted",
	1: "Blacklisted",
	2: "Rejected",
}

var AdmissionControlStatusCode_value = map[string]int32{
	"Accepted":    0,
	"Blacklisted": 1,
	"Rejected":    2,
}

func (AdmissionControlStatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d13d6ff9aac892b4, []int{0}
}

// -----------------------------------------------------------------------------
// ---------------- Submit transaction
// -----------------------------------------------------------------------------
// The request for transaction submission.
type SubmitTransactionRequest struct {
	// Transaction signed by wallet.
	SignedTxn *types.SignedTransaction `protobuf:"bytes,1,opt,name=signed_txn,json=signedTxn,proto3" json:"signed_txn,omitempty"`
}

func (m *SubmitTransactionRequest) Reset()      { *m = SubmitTransactionRequest{} }
func (*SubmitTransactionRequest) ProtoMessage() {}
func (*SubmitTransactionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d13d6ff9aac892b4, []int{0}
}
func (m *SubmitTransactionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubmitTransactionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubmitTransactionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubmitTransactionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitTransactionRequest.Merge(m, src)
}
func (m *SubmitTransactionRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubmitTransactionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitTransactionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitTransactionRequest proto.InternalMessageInfo

func (m *SubmitTransactionRequest) GetSignedTxn() *types.SignedTransaction {
	if m != nil {
		return m.SignedTxn
	}
	return nil
}

// AC response status containing code and optionally an error message.
type AdmissionControlStatus struct {
	Code    AdmissionControlStatusCode `protobuf:"varint,1,opt,name=code,proto3,enum=admission_control.AdmissionControlStatusCode" json:"code,omitempty"`
	Message string                     `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *AdmissionControlStatus) Reset()      { *m = AdmissionControlStatus{} }
func (*AdmissionControlStatus) ProtoMessage() {}
func (*AdmissionControlStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_d13d6ff9aac892b4, []int{1}
}
func (m *AdmissionControlStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdmissionControlStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdmissionControlStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdmissionControlStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdmissionControlStatus.Merge(m, src)
}
func (m *AdmissionControlStatus) XXX_Size() int {
	return m.Size()
}
func (m *AdmissionControlStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_AdmissionControlStatus.DiscardUnknown(m)
}

var xxx_messageInfo_AdmissionControlStatus proto.InternalMessageInfo

func (m *AdmissionControlStatus) GetCode() AdmissionControlStatusCode {
	if m != nil {
		return m.Code
	}
	return Accepted
}

func (m *AdmissionControlStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// The response for transaction submission.
//
// How does a client know if their transaction was included?
// A response from the transaction submission only means that the transaction
// was successfully added to mempool, but not that it is guaranteed to be
// included in the chain.  Each transaction should include an expiration time in
// the signed transaction.  Let's call this T0.  As a client, I submit my
// transaction to a validator. I now need to poll for the transaction I
// submitted.  I can use the query that takes my account and sequence number. If
// I receive back that the transaction is completed, I will verify the proofs to
// ensure that this is the transaction I expected.  If I receive a response that
// my transaction is not yet completed, I must check the latest timestamp in the
// ledgerInfo that I receive back from the query.  If this time is greater than
// T0, I can be certain that my transaction will never be included.  If this
// time is less than T0, I need to continue polling.
type SubmitTransactionResponse struct {
	// The status of a transaction submission can either be a VM status, or
	// some other admission control/mempool specific status e.g. Blacklisted.
	//
	// Types that are valid to be assigned to Status:
	//	*SubmitTransactionResponse_VmStatus
	//	*SubmitTransactionResponse_AcStatus
	//	*SubmitTransactionResponse_MempoolStatus
	Status isSubmitTransactionResponse_Status `protobuf_oneof:"status"`
	// Public key(id) of the validator that processed this transaction
	ValidatorId []byte `protobuf:"bytes,4,opt,name=validator_id,json=validatorId,proto3" json:"validator_id,omitempty"`
}

func (m *SubmitTransactionResponse) Reset()      { *m = SubmitTransactionResponse{} }
func (*SubmitTransactionResponse) ProtoMessage() {}
func (*SubmitTransactionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d13d6ff9aac892b4, []int{2}
}
func (m *SubmitTransactionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubmitTransactionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubmitTransactionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubmitTransactionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitTransactionResponse.Merge(m, src)
}
func (m *SubmitTransactionResponse) XXX_Size() int {
	return m.Size()
}
func (m *SubmitTransactionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitTransactionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitTransactionResponse proto.InternalMessageInfo

type isSubmitTransactionResponse_Status interface {
	isSubmitTransactionResponse_Status()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type SubmitTransactionResponse_VmStatus struct {
	VmStatus *types.VMStatus `protobuf:"bytes,1,opt,name=vm_status,json=vmStatus,proto3,oneof"`
}
type SubmitTransactionResponse_AcStatus struct {
	AcStatus *AdmissionControlStatus `protobuf:"bytes,2,opt,name=ac_status,json=acStatus,proto3,oneof"`
}
type SubmitTransactionResponse_MempoolStatus struct {
	MempoolStatus *mempool.MempoolAddTransactionStatus `protobuf:"bytes,3,opt,name=mempool_status,json=mempoolStatus,proto3,oneof"`
}

func (*SubmitTransactionResponse_VmStatus) isSubmitTransactionResponse_Status()      {}
func (*SubmitTransactionResponse_AcStatus) isSubmitTransactionResponse_Status()      {}
func (*SubmitTransactionResponse_MempoolStatus) isSubmitTransactionResponse_Status() {}

func (m *SubmitTransactionResponse) GetStatus() isSubmitTransactionResponse_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SubmitTransactionResponse) GetVmStatus() *types.VMStatus {
	if x, ok := m.GetStatus().(*SubmitTransactionResponse_VmStatus); ok {
		return x.VmStatus
	}
	return nil
}

func (m *SubmitTransactionResponse) GetAcStatus() *AdmissionControlStatus {
	if x, ok := m.GetStatus().(*SubmitTransactionResponse_AcStatus); ok {
		return x.AcStatus
	}
	return nil
}

func (m *SubmitTransactionResponse) GetMempoolStatus() *mempool.MempoolAddTransactionStatus {
	if x, ok := m.GetStatus().(*SubmitTransactionResponse_MempoolStatus); ok {
		return x.MempoolStatus
	}
	return nil
}

func (m *SubmitTransactionResponse) GetValidatorId() []byte {
	if m != nil {
		return m.ValidatorId
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SubmitTransactionResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SubmitTransactionResponse_OneofMarshaler, _SubmitTransactionResponse_OneofUnmarshaler, _SubmitTransactionResponse_OneofSizer, []interface{}{
		(*SubmitTransactionResponse_VmStatus)(nil),
		(*SubmitTransactionResponse_AcStatus)(nil),
		(*SubmitTransactionResponse_MempoolStatus)(nil),
	}
}

func _SubmitTransactionResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SubmitTransactionResponse)
	// status
	switch x := m.Status.(type) {
	case *SubmitTransactionResponse_VmStatus:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.VmStatus); err != nil {
			return err
		}
	case *SubmitTransactionResponse_AcStatus:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AcStatus); err != nil {
			return err
		}
	case *SubmitTransactionResponse_MempoolStatus:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MempoolStatus); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SubmitTransactionResponse.Status has unexpected type %T", x)
	}
	return nil
}

func _SubmitTransactionResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SubmitTransactionResponse)
	switch tag {
	case 1: // status.vm_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(types.VMStatus)
		err := b.DecodeMessage(msg)
		m.Status = &SubmitTransactionResponse_VmStatus{msg}
		return true, err
	case 2: // status.ac_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AdmissionControlStatus)
		err := b.DecodeMessage(msg)
		m.Status = &SubmitTransactionResponse_AcStatus{msg}
		return true, err
	case 3: // status.mempool_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(mempool.MempoolAddTransactionStatus)
		err := b.DecodeMessage(msg)
		m.Status = &SubmitTransactionResponse_MempoolStatus{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SubmitTransactionResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SubmitTransactionResponse)
	// status
	switch x := m.Status.(type) {
	case *SubmitTransactionResponse_VmStatus:
		s := proto.Size(x.VmStatus)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SubmitTransactionResponse_AcStatus:
		s := proto.Size(x.AcStatus)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SubmitTransactionResponse_MempoolStatus:
		s := proto.Size(x.MempoolStatus)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterEnum("admission_control.AdmissionControlStatusCode", AdmissionControlStatusCode_name, AdmissionControlStatusCode_value)
	proto.RegisterType((*SubmitTransactionRequest)(nil), "admission_control.SubmitTransactionRequest")
	proto.RegisterType((*AdmissionControlStatus)(nil), "admission_control.AdmissionControlStatus")
	proto.RegisterType((*SubmitTransactionResponse)(nil), "admission_control.SubmitTransactionResponse")
}

func init() { proto.RegisterFile("admission_control.proto", fileDescriptor_d13d6ff9aac892b4) }

var fileDescriptor_d13d6ff9aac892b4 = []byte{
	// 499 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x53, 0x4d, 0x73, 0x12, 0x41,
	0x10, 0xdd, 0xc1, 0x54, 0x84, 0x06, 0x43, 0x98, 0xa2, 0x74, 0xe5, 0x30, 0x85, 0xe8, 0x01, 0xbf,
	0xf6, 0x80, 0x56, 0x79, 0x86, 0x5c, 0x92, 0xaa, 0x70, 0x59, 0xd0, 0xeb, 0xd6, 0x64, 0xa7, 0xc5,
	0x55, 0x76, 0x67, 0xdd, 0x19, 0x30, 0xde, 0xfc, 0x09, 0xfa, 0x2f, 0xfc, 0x29, 0x1e, 0x39, 0xe6,
	0x28, 0xcb, 0x41, 0x8f, 0xf9, 0x09, 0x16, 0xbb, 0xb3, 0x31, 0x0a, 0x49, 0xe5, 0x44, 0xcd, 0xeb,
	0xd7, 0xaf, 0x5f, 0xbf, 0x66, 0xe1, 0x1e, 0x17, 0x61, 0xa0, 0x54, 0x20, 0x23, 0xcf, 0x97, 0x91,
	0x4e, 0xe4, 0xd4, 0x89, 0x13, 0xa9, 0x25, 0x6d, 0x6c, 0x14, 0x5a, 0xcd, 0x09, 0x6a, 0xef, 0x53,
	0xa0, 0xdf, 0x79, 0x71, 0x22, 0xe5, 0xdb, 0x9c, 0xd8, 0x6a, 0x86, 0x18, 0xc6, 0x52, 0x4e, 0x3d,
	0xa5, 0xb9, 0x9e, 0x29, 0x83, 0x36, 0x74, 0xc2, 0x23, 0xc5, 0x7d, 0x1d, 0xc8, 0xc8, 0x40, 0xf5,
	0x79, 0xe8, 0x61, 0x92, 0xc8, 0xc4, 0x70, 0x3a, 0x23, 0xb0, 0x47, 0xb3, 0x93, 0x30, 0xd0, 0xe3,
	0xbf, 0x5c, 0x17, 0x3f, 0xce, 0x50, 0x69, 0xfa, 0x0a, 0x40, 0x05, 0x93, 0x08, 0x85, 0xa7, 0x4f,
	0x23, 0x9b, 0xb4, 0x49, 0xb7, 0xda, 0xb3, 0x1d, 0xfd, 0x39, 0x46, 0xe5, 0x8c, 0xb2, 0xc2, 0xe5,
	0xa6, 0x4a, 0xce, 0x1d, 0x9f, 0x46, 0x9d, 0x19, 0xdc, 0xed, 0x17, 0xce, 0x0f, 0x72, 0xe3, 0xa3,
	0xcc, 0x18, 0xed, 0xc3, 0x8e, 0x2f, 0x05, 0x66, 0x62, 0x7b, 0xbd, 0xe7, 0xce, 0xe6, 0xe6, 0xdb,
	0x1b, 0x0f, 0xa4, 0x40, 0x37, 0x6b, 0xa5, 0x36, 0xdc, 0x0e, 0x51, 0x29, 0x3e, 0x41, 0xbb, 0xd4,
	0x26, 0xdd, 0x8a, 0x5b, 0x3c, 0x3b, 0xdf, 0x4a, 0x70, 0x7f, 0xcb, 0x32, 0x2a, 0x96, 0x91, 0x42,
	0xea, 0x40, 0x65, 0x1e, 0x9a, 0x80, 0xcc, 0x32, 0x75, 0xb3, 0xcc, 0x9b, 0x61, 0x3e, 0xe5, 0xd0,
	0x72, 0xcb, 0xf3, 0xd0, 0x58, 0x3d, 0x84, 0x0a, 0xf7, 0x0b, 0x7e, 0x29, 0xe3, 0x3f, 0xbe, 0xb1,
	0xdf, 0xb5, 0x12, 0xf7, 0x8d, 0xd2, 0x10, 0xf6, 0xfe, 0xbd, 0x8f, 0x7d, 0x2b, 0x93, 0x7b, 0xe4,
	0x18, 0xd8, 0x19, 0xe6, 0xbf, 0x7d, 0x71, 0x39, 0xd1, 0x0b, 0xa5, 0x3b, 0x86, 0x66, 0xe4, 0x1e,
	0x40, 0x6d, 0xce, 0xa7, 0x81, 0xe0, 0x5a, 0x26, 0x5e, 0x20, 0xec, 0x9d, 0x36, 0xe9, 0xd6, 0xdc,
	0xea, 0x05, 0x76, 0x24, 0x06, 0x65, 0xd8, 0xcd, 0x27, 0x3d, 0x39, 0x82, 0xd6, 0xd5, 0x89, 0xd2,
	0x1a, 0x94, 0xfb, 0xbe, 0x8f, 0xb1, 0x46, 0xb1, 0x6f, 0xd1, 0x3a, 0x54, 0x07, 0x53, 0xee, 0x7f,
	0x98, 0x06, 0x6a, 0x0d, 0x90, 0x75, 0xd9, 0xc5, 0xf7, 0xe8, 0xaf, 0x5f, 0xa5, 0xde, 0x2f, 0x02,
	0xfb, 0xff, 0x6b, 0xd1, 0x18, 0x1a, 0x1b, 0x91, 0xd3, 0xa7, 0x5b, 0x72, 0xba, 0xea, 0x5f, 0xd6,
	0x7a, 0x76, 0x33, 0x72, 0x7e, 0xc5, 0x8e, 0x45, 0x39, 0x34, 0x5f, 0xc7, 0x82, 0x6b, 0x1c, 0xcb,
	0x63, 0xae, 0x51, 0xe9, 0x63, 0x14, 0x13, 0x4c, 0x68, 0xc7, 0x1c, 0x73, 0x5b, 0xb1, 0x98, 0xf5,
	0xf0, 0x5a, 0x4e, 0x31, 0x62, 0xf0, 0x72, 0xb1, 0x64, 0xd6, 0xd9, 0x92, 0x59, 0xe7, 0x4b, 0x46,
	0xbe, 0xa4, 0x8c, 0x7c, 0x4f, 0x19, 0xf9, 0x91, 0x32, 0xb2, 0x48, 0x19, 0xf9, 0x99, 0x32, 0xf2,
	0x3b, 0x65, 0xd6, 0x79, 0xca, 0xc8, 0xd7, 0x15, 0xb3, 0x16, 0x2b, 0x66, 0x9d, 0xad, 0x98, 0x75,
	0xb2, 0x9b, 0x7d, 0x51, 0x2f, 0xfe, 0x04, 0x00, 0x00, 0xff, 0xff, 0xb8, 0xbf, 0xfe, 0x34, 0xcf,
	0x03, 0x00, 0x00,
}

func (x AdmissionControlStatusCode) String() string {
	s, ok := AdmissionControlStatusCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *SubmitTransactionRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubmitTransactionRequest)
	if !ok {
		that2, ok := that.(SubmitTransactionRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SignedTxn.Equal(that1.SignedTxn) {
		return false
	}
	return true
}
func (this *AdmissionControlStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdmissionControlStatus)
	if !ok {
		that2, ok := that.(AdmissionControlStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Message != that1.Message {
		return false
	}
	return true
}
func (this *SubmitTransactionResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubmitTransactionResponse)
	if !ok {
		that2, ok := that.(SubmitTransactionResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Status == nil {
		if this.Status != nil {
			return false
		}
	} else if this.Status == nil {
		return false
	} else if !this.Status.Equal(that1.Status) {
		return false
	}
	if !bytes.Equal(this.ValidatorId, that1.ValidatorId) {
		return false
	}
	return true
}
func (this *SubmitTransactionResponse_VmStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubmitTransactionResponse_VmStatus)
	if !ok {
		that2, ok := that.(SubmitTransactionResponse_VmStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.VmStatus.Equal(that1.VmStatus) {
		return false
	}
	return true
}
func (this *SubmitTransactionResponse_AcStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubmitTransactionResponse_AcStatus)
	if !ok {
		that2, ok := that.(SubmitTransactionResponse_AcStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AcStatus.Equal(that1.AcStatus) {
		return false
	}
	return true
}
func (this *SubmitTransactionResponse_MempoolStatus) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubmitTransactionResponse_MempoolStatus)
	if !ok {
		that2, ok := that.(SubmitTransactionResponse_MempoolStatus)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MempoolStatus.Equal(that1.MempoolStatus) {
		return false
	}
	return true
}
func (this *SubmitTransactionRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&admission_control.SubmitTransactionRequest{")
	if this.SignedTxn != nil {
		s = append(s, "SignedTxn: "+fmt.Sprintf("%#v", this.SignedTxn)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AdmissionControlStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&admission_control.AdmissionControlStatus{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SubmitTransactionResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&admission_control.SubmitTransactionResponse{")
	if this.Status != nil {
		s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	}
	s = append(s, "ValidatorId: "+fmt.Sprintf("%#v", this.ValidatorId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SubmitTransactionResponse_VmStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&admission_control.SubmitTransactionResponse_VmStatus{` +
		`VmStatus:` + fmt.Sprintf("%#v", this.VmStatus) + `}`}, ", ")
	return s
}
func (this *SubmitTransactionResponse_AcStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&admission_control.SubmitTransactionResponse_AcStatus{` +
		`AcStatus:` + fmt.Sprintf("%#v", this.AcStatus) + `}`}, ", ")
	return s
}
func (this *SubmitTransactionResponse_MempoolStatus) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&admission_control.SubmitTransactionResponse_MempoolStatus{` +
		`MempoolStatus:` + fmt.Sprintf("%#v", this.MempoolStatus) + `}`}, ", ")
	return s
}
func valueToGoStringAdmissionControl(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *SubmitTransactionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubmitTransactionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SignedTxn != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdmissionControl(dAtA, i, uint64(m.SignedTxn.Size()))
		n1, err1 := m.SignedTxn.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	return i, nil
}

func (m *AdmissionControlStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdmissionControlStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAdmissionControl(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdmissionControl(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *SubmitTransactionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubmitTransactionResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		nn2, err2 := m.Status.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += nn2
	}
	if len(m.ValidatorId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAdmissionControl(dAtA, i, uint64(len(m.ValidatorId)))
		i += copy(dAtA[i:], m.ValidatorId)
	}
	return i, nil
}

func (m *SubmitTransactionResponse_VmStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.VmStatus != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdmissionControl(dAtA, i, uint64(m.VmStatus.Size()))
		n3, err3 := m.VmStatus.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	return i, nil
}
func (m *SubmitTransactionResponse_AcStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AcStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdmissionControl(dAtA, i, uint64(m.AcStatus.Size()))
		n4, err4 := m.AcStatus.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	return i, nil
}
func (m *SubmitTransactionResponse_MempoolStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.MempoolStatus != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdmissionControl(dAtA, i, uint64(m.MempoolStatus.Size()))
		n5, err5 := m.MempoolStatus.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	return i, nil
}
func encodeVarintAdmissionControl(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SubmitTransactionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignedTxn != nil {
		l = m.SignedTxn.Size()
		n += 1 + l + sovAdmissionControl(uint64(l))
	}
	return n
}

func (m *AdmissionControlStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovAdmissionControl(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAdmissionControl(uint64(l))
	}
	return n
}

func (m *SubmitTransactionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		n += m.Status.Size()
	}
	l = len(m.ValidatorId)
	if l > 0 {
		n += 1 + l + sovAdmissionControl(uint64(l))
	}
	return n
}

func (m *SubmitTransactionResponse_VmStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VmStatus != nil {
		l = m.VmStatus.Size()
		n += 1 + l + sovAdmissionControl(uint64(l))
	}
	return n
}
func (m *SubmitTransactionResponse_AcStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AcStatus != nil {
		l = m.AcStatus.Size()
		n += 1 + l + sovAdmissionControl(uint64(l))
	}
	return n
}
func (m *SubmitTransactionResponse_MempoolStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MempoolStatus != nil {
		l = m.MempoolStatus.Size()
		n += 1 + l + sovAdmissionControl(uint64(l))
	}
	return n
}

func sovAdmissionControl(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAdmissionControl(x uint64) (n int) {
	return sovAdmissionControl(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *SubmitTransactionRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SubmitTransactionRequest{`,
		`SignedTxn:` + strings.Replace(fmt.Sprintf("%v", this.SignedTxn), "SignedTransaction", "types.SignedTransaction", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AdmissionControlStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AdmissionControlStatus{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Message:` + fmt.Sprintf("%v", this.Message) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SubmitTransactionResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SubmitTransactionResponse{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`ValidatorId:` + fmt.Sprintf("%v", this.ValidatorId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SubmitTransactionResponse_VmStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SubmitTransactionResponse_VmStatus{`,
		`VmStatus:` + strings.Replace(fmt.Sprintf("%v", this.VmStatus), "VMStatus", "types.VMStatus", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SubmitTransactionResponse_AcStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SubmitTransactionResponse_AcStatus{`,
		`AcStatus:` + strings.Replace(fmt.Sprintf("%v", this.AcStatus), "AdmissionControlStatus", "AdmissionControlStatus", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SubmitTransactionResponse_MempoolStatus) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SubmitTransactionResponse_MempoolStatus{`,
		`MempoolStatus:` + strings.Replace(fmt.Sprintf("%v", this.MempoolStatus), "MempoolAddTransactionStatus", "mempool.MempoolAddTransactionStatus", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringAdmissionControl(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *SubmitTransactionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmissionControl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubmitTransactionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubmitTransactionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmissionControl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmissionControl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmissionControl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignedTxn == nil {
				m.SignedTxn = &types.SignedTransaction{}
			}
			if err := m.SignedTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmissionControl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmissionControl
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdmissionControl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdmissionControlStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmissionControl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdmissionControlStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdmissionControlStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmissionControl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= AdmissionControlStatusCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmissionControl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmissionControl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmissionControl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmissionControl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmissionControl
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdmissionControl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubmitTransactionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmissionControl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubmitTransactionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubmitTransactionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmissionControl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmissionControl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmissionControl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.VMStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Status = &SubmitTransactionResponse_VmStatus{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmissionControl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmissionControl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmissionControl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AdmissionControlStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Status = &SubmitTransactionResponse_AcStatus{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MempoolStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmissionControl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmissionControl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmissionControl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &mempool.MempoolAddTransactionStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Status = &SubmitTransactionResponse_MempoolStatus{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmissionControl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdmissionControl
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmissionControl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorId = append(m.ValidatorId[:0], dAtA[iNdEx:postIndex]...)
			if m.ValidatorId == nil {
				m.ValidatorId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmissionControl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdmissionControl
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAdmissionControl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAdmissionControl(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAdmissionControl
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdmissionControl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdmissionControl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAdmissionControl
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthAdmissionControl
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAdmissionControl
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAdmissionControl(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthAdmissionControl
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAdmissionControl = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAdmissionControl   = fmt.Errorf("proto: integer overflow")
)
